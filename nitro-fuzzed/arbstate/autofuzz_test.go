package arbcompressfuzz

// Edit if desired. Code generated by "go-fuzz-fill-utils ./arbstate/".

import (
	"io"
	"testing"

	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/arbstate"
	"github.com/offchainlabs/nitro/blsSignatures"
)

// skipping Fuzz_DataAvailabilityCertificate_RecoverKeyset because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbstate.DataAvailabilityReader

func Fuzz_DataAvailabilityCertificate_SerializeSignableFields(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rd io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rd)

		c, err := arbstate.DeserializeDASCertFrom(rd)
		if err != nil {
			return
		}
		c.SerializeSignableFields()
	})
}

func Fuzz_DataAvailabilityKeyset_Hash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rd io.Reader
		var assumeKeysetValid bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rd, &assumeKeysetValid)

		keyset, err := arbstate.DeserializeKeyset(rd, assumeKeysetValid)
		if err != nil {
			return
		}
		keyset.Hash()
	})
}

func Fuzz_DataAvailabilityKeyset_Serialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rd io.Reader
		var assumeKeysetValid bool
		var wr io.Writer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rd, &assumeKeysetValid, &wr)

		keyset, err := arbstate.DeserializeKeyset(rd, assumeKeysetValid)
		if err != nil {
			return
		}
		keyset.Serialize(wr)
	})
}

func Fuzz_DataAvailabilityKeyset_VerifySignature(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rd io.Reader
		var assumeKeysetValid bool
		var signersMask uint64
		var d4 []byte
		var sig blsSignatures.Signature
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rd, &assumeKeysetValid, &signersMask, &d4, &sig)

		keyset, err := arbstate.DeserializeKeyset(rd, assumeKeysetValid)
		if err != nil {
			return
		}
		keyset.VerifySignature(signersMask, d4, sig)
	})
}

func Fuzz_ExpirationPolicy_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, s string) {
		ep, err := arbstate.StringToExpirationPolicy(s)
		if err != nil {
			return
		}
		ep.String()
	})
}

func Fuzz_DeserializeDASCertFrom(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rd io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rd)

		arbstate.DeserializeDASCertFrom(rd)
	})
}

func Fuzz_DeserializeKeyset(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rd io.Reader
		var assumeKeysetValid bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rd, &assumeKeysetValid)

		arbstate.DeserializeKeyset(rd, assumeKeysetValid)
	})
}

func Fuzz_IsBrotliMessageHeaderByte(f *testing.F) {
	f.Fuzz(func(t *testing.T, b uint8) {
		arbstate.IsBrotliMessageHeaderByte(b)
	})
}

func Fuzz_IsDASMessageHeaderByte(f *testing.F) {
	f.Fuzz(func(t *testing.T, header byte) {
		arbstate.IsDASMessageHeaderByte(header)
	})
}

func Fuzz_IsTreeDASMessageHeaderByte(f *testing.F) {
	f.Fuzz(func(t *testing.T, header byte) {
		arbstate.IsTreeDASMessageHeaderByte(header)
	})
}

func Fuzz_IsZeroheavyEncodedHeaderByte(f *testing.F) {
	f.Fuzz(func(t *testing.T, header byte) {
		arbstate.IsZeroheavyEncodedHeaderByte(header)
	})
}

// skipping Fuzz_NewInboxMultiplexer because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbstate.InboxBackend

// skipping Fuzz_RecoverPayloadFromDasBatch because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbstate.DataAvailabilityReader

func Fuzz_StringToExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, s string) {
		arbstate.StringToExpirationPolicy(s)
	})
}
