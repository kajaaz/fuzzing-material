package arbcompressfuzz

// Edit if desired. Code generated by "go-fuzz-fill-utils ./arbnode/".

import (
	"context"
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/params"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/arbnode"
	"github.com/offchainlabs/nitro/arbos/arbostypes"
	"github.com/offchainlabs/nitro/arbutil"
	"github.com/offchainlabs/nitro/broadcaster"
	"github.com/offchainlabs/nitro/staker"
	"github.com/offchainlabs/nitro/validator"
	"github.com/spf13/pflag"
)

func Fuzz_BatchPoster_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *arbnode.BatchPoster
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctxIn)
		if b == nil {
			return
		}

		b.Start(ctxIn)
	})
}

func Fuzz_BatchPoster_StopAndWait(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *arbnode.BatchPoster
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b)
		if b == nil {
			return
		}

		b.StopAndWait()
	})
}

func Fuzz_BatchPosterConfig_Validate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.BatchPosterConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.Validate()
	})
}

func Fuzz_BlockValidatorAPI_LatestValidated(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var a *arbnode.BlockValidatorAPI
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&a, &ctx)
		if a == nil {
			return
		}

		a.LatestValidated(ctx)
	})
}

func Fuzz_BlockValidatorDebugAPI_ValidateMessageNumber(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var a *arbnode.BlockValidatorDebugAPI
		var ctx context.Context
		var msgNum hexutil.Uint64
		var full bool
		var moduleRootOptional *common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&a, &ctx, &msgNum, &full, &moduleRootOptional)
		if a == nil || moduleRootOptional == nil {
			return
		}

		a.ValidateMessageNumber(ctx, msgNum, full, moduleRootOptional)
	})
}

func Fuzz_ClassicOutboxRetriever_GetMsg(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *arbnode.ClassicOutboxRetriever
		var batchNum *big.Int
		var index uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &batchNum, &index)
		if m == nil || batchNum == nil {
			return
		}

		m.GetMsg(batchNum, index)
	})
}

func Fuzz_DelayedBridge_FirstBlock(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *arbnode.DelayedBridge
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b)
		if b == nil {
			return
		}

		b.FirstBlock()
	})
}

func Fuzz_DelayedBridge_GetAccumulator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *arbnode.DelayedBridge
		var ctx context.Context
		var sequenceNumber uint64
		var blockNumber *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx, &sequenceNumber, &blockNumber)
		if b == nil || blockNumber == nil {
			return
		}

		b.GetAccumulator(ctx, sequenceNumber, blockNumber)
	})
}

func Fuzz_DelayedBridge_GetMessageCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *arbnode.DelayedBridge
		var ctx context.Context
		var blockNumber *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx, &blockNumber)
		if b == nil || blockNumber == nil {
			return
		}

		b.GetMessageCount(ctx, blockNumber)
	})
}

// skipping Fuzz_DelayedBridge_LookupMessagesInRange because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbos/arbostypes.FallibleBatchFetcher

func Fuzz_DelayedInboxMessage_AfterInboxAcc(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *arbnode.DelayedInboxMessage
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m)
		if m == nil {
			return
		}

		m.AfterInboxAcc()
	})
}

func Fuzz_DelayedSequencer_ForceSequenceDelayed(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var d *arbnode.DelayedSequencer
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&d, &ctx)
		if d == nil {
			return
		}

		d.ForceSequenceDelayed(ctx)
	})
}

func Fuzz_DelayedSequencer_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var d *arbnode.DelayedSequencer
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&d, &ctxIn)
		if d == nil {
			return
		}

		d.Start(ctxIn)
	})
}

func Fuzz_InboxReader_CaughtUp(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.CaughtUp()
	})
}

func Fuzz_InboxReader_DelayedBridge(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.DelayedBridge()
	})
}

func Fuzz_InboxReader_GetDelayBlocks(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetDelayBlocks()
	})
}

func Fuzz_InboxReader_GetFinalizedMsgCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.GetFinalizedMsgCount(ctx)
	})
}

func Fuzz_InboxReader_GetLastReadBlockAndBatchCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetLastReadBlockAndBatchCount()
	})
}

func Fuzz_InboxReader_GetLastSeenBatchCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.GetLastSeenBatchCount()
	})
}

func Fuzz_InboxReader_GetSafeMsgCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.GetSafeMsgCount(ctx)
	})
}

func Fuzz_InboxReader_GetSequencerMessageBytes(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		var ctx context.Context
		var seqNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx, &seqNum)
		if r == nil {
			return
		}

		r.GetSequencerMessageBytes(ctx, seqNum)
	})
}

func Fuzz_InboxReader_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctxIn)
		if r == nil {
			return
		}

		r.Start(ctxIn)
	})
}

func Fuzz_InboxReader_Tracker(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *arbnode.InboxReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.Tracker()
	})
}

func Fuzz_InboxReaderConfig_Validate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.InboxReaderConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.Validate()
	})
}

func Fuzz_InboxTracker_AddDelayedMessages(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var messages []*arbnode.DelayedInboxMessage
		var hardReorg bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &messages, &hardReorg)
		if t1 == nil {
			return
		}

		t1.AddDelayedMessages(messages, hardReorg)
	})
}

// skipping Fuzz_InboxTracker_AddSequencerBatches because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

func Fuzz_InboxTracker_GetBatchAcc(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var seqNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &seqNum)
		if t1 == nil {
			return
		}

		t1.GetBatchAcc(seqNum)
	})
}

func Fuzz_InboxTracker_GetBatchCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1)
		if t1 == nil {
			return
		}

		t1.GetBatchCount()
	})
}

func Fuzz_InboxTracker_GetBatchMessageCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var seqNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &seqNum)
		if t1 == nil {
			return
		}

		t1.GetBatchMessageCount(seqNum)
	})
}

func Fuzz_InboxTracker_GetBatchMetadata(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var seqNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &seqNum)
		if t1 == nil {
			return
		}

		t1.GetBatchMetadata(seqNum)
	})
}

func Fuzz_InboxTracker_GetDelayedAcc(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var seqNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &seqNum)
		if t1 == nil {
			return
		}

		t1.GetDelayedAcc(seqNum)
	})
}

func Fuzz_InboxTracker_GetDelayedCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1)
		if t1 == nil {
			return
		}

		t1.GetDelayedCount()
	})
}

func Fuzz_InboxTracker_GetDelayedMessage(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var seqNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &seqNum)
		if t1 == nil {
			return
		}

		t1.GetDelayedMessage(seqNum)
	})
}

func Fuzz_InboxTracker_GetDelayedMessageAccumulatorAndParentChainBlockNumber(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var seqNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &seqNum)
		if t1 == nil {
			return
		}

		t1.GetDelayedMessageAccumulatorAndParentChainBlockNumber(seqNum)
	})
}

func Fuzz_InboxTracker_GetDelayedMessageBytes(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var seqNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &seqNum)
		if t1 == nil {
			return
		}

		t1.GetDelayedMessageBytes(seqNum)
	})
}

func Fuzz_InboxTracker_Initialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1)
		if t1 == nil {
			return
		}

		t1.Initialize()
	})
}

func Fuzz_InboxTracker_PopulateFeedBacklog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var broadcastServer *broadcaster.Broadcaster
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &broadcastServer)
		if t1 == nil || broadcastServer == nil {
			return
		}

		t1.PopulateFeedBacklog(broadcastServer)
	})
}

func Fuzz_InboxTracker_ReorgBatchesTo(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var count uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &count)
		if t1 == nil {
			return
		}

		t1.ReorgBatchesTo(count)
	})
}

func Fuzz_InboxTracker_ReorgDelayedTo(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var count uint64
		var canReorgBatches bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &count, &canReorgBatches)
		if t1 == nil {
			return
		}

		t1.ReorgDelayedTo(count, canReorgBatches)
	})
}

func Fuzz_InboxTracker_SetBlockValidator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *arbnode.InboxTracker
		var validator *staker.BlockValidator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &validator)
		if t1 == nil || validator == nil {
			return
		}

		t1.SetBlockValidator(validator)
	})
}

func Fuzz_MaintenanceConfig_Validate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.MaintenanceConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.Validate()
	})
}

func Fuzz_MaintenanceRunner_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var mr *arbnode.MaintenanceRunner
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&mr, &ctxIn)
		if mr == nil {
			return
		}

		mr.Start(ctxIn)
	})
}

func Fuzz_MessagePruner_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *arbnode.MessagePruner
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctxIn)
		if m == nil {
			return
		}

		m.Start(ctxIn)
	})
}

func Fuzz_MessagePruner_UpdateLatestConfirmed(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *arbnode.MessagePruner
		var count arbutil.MessageIndex
		var globalState validator.GoGlobalState
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &count, &globalState)
		if m == nil {
			return
		}

		m.UpdateLatestConfirmed(count, globalState)
	})
}

func Fuzz_Node_OnConfigReload(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n *arbnode.Node
		var _x2 *arbnode.Config
		var _x3 *arbnode.Config
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &_x2, &_x3)
		if n == nil || _x2 == nil || _x3 == nil {
			return
		}

		n.OnConfigReload(_x2, _x3)
	})
}

func Fuzz_Node_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n *arbnode.Node
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &ctx)
		if n == nil {
			return
		}

		n.Start(ctx)
	})
}

func Fuzz_Node_StopAndWait(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n *arbnode.Node
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n)
		if n == nil {
			return
		}

		n.StopAndWait()
	})
}

func Fuzz_SeqCoordinator_AvoidLockout(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &ctx)
		if c == nil {
			return
		}

		c.AvoidLockout(ctx)
	})
}

func Fuzz_SeqCoordinator_AvoidingLockout(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.AvoidingLockout()
	})
}

func Fuzz_SeqCoordinator_CurrentlyChosen(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.CurrentlyChosen()
	})
}

func Fuzz_SeqCoordinator_DebugPrint(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.DebugPrint()
	})
}

func Fuzz_SeqCoordinator_GetRemoteMsgCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.GetRemoteMsgCount()
	})
}

func Fuzz_SeqCoordinator_PrepareForShutdown(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.PrepareForShutdown()
	})
}

func Fuzz_SeqCoordinator_SeekLockout(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &ctx)
		if c == nil {
			return
		}

		c.SeekLockout(ctx)
	})
}

func Fuzz_SeqCoordinator_SequencingMessage(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		var pos arbutil.MessageIndex
		var msg *arbostypes.MessageWithMetadata
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &pos, &msg)
		if c == nil || msg == nil {
			return
		}

		c.SequencingMessage(pos, msg)
	})
}

func Fuzz_SeqCoordinator_SetDelayedSequencer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		var delayedSequencer *arbnode.DelayedSequencer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &delayedSequencer)
		if c == nil || delayedSequencer == nil {
			return
		}

		c.SetDelayedSequencer(delayedSequencer)
	})
}

func Fuzz_SeqCoordinator_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &ctxIn)
		if c == nil {
			return
		}

		c.Start(ctxIn)
	})
}

func Fuzz_SeqCoordinator_StopAndWait(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.StopAndWait()
	})
}

func Fuzz_SeqCoordinator_TryToHandoffChosenOne(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinator
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &ctx)
		if c == nil {
			return
		}

		c.TryToHandoffChosenOne(ctx)
	})
}

func Fuzz_SeqCoordinatorConfig_Url(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbnode.SeqCoordinatorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.Url()
	})
}

func Fuzz_SequencerInbox_GetAccumulator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *arbnode.SequencerInbox
		var ctx context.Context
		var sequenceNumber uint64
		var blockNumber *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &ctx, &sequenceNumber, &blockNumber)
		if i == nil || blockNumber == nil {
			return
		}

		i.GetAccumulator(ctx, sequenceNumber, blockNumber)
	})
}

func Fuzz_SequencerInbox_GetBatchCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *arbnode.SequencerInbox
		var ctx context.Context
		var blockNumber *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &ctx, &blockNumber)
		if i == nil || blockNumber == nil {
			return
		}

		i.GetBatchCount(ctx, blockNumber)
	})
}

func Fuzz_SequencerInbox_LookupBatchesInRange(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *arbnode.SequencerInbox
		var ctx context.Context
		var from *big.Int
		var to *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &ctx, &from, &to)
		if i == nil || from == nil || to == nil {
			return
		}

		i.LookupBatchesInRange(ctx, from, to)
	})
}

// skipping Fuzz_SequencerInboxBatch_Serialize because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

func Fuzz_SyncMonitor_FinalizedBlockNumber(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *arbnode.SyncMonitorConfig
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &ctx)
		if config == nil {
			return
		}

		s := arbnode.NewSyncMonitor(config)
		s.FinalizedBlockNumber(ctx)
	})
}

func Fuzz_SyncMonitor_Initialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *arbnode.SyncMonitorConfig
		var inboxReader *arbnode.InboxReader
		var txStreamer *arbnode.TransactionStreamer
		var coordinator *arbnode.SeqCoordinator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &inboxReader, &txStreamer, &coordinator)
		if config == nil || inboxReader == nil || txStreamer == nil || coordinator == nil {
			return
		}

		s := arbnode.NewSyncMonitor(config)
		s.Initialize(inboxReader, txStreamer, coordinator)
	})
}

func Fuzz_SyncMonitor_SafeBlockNumber(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *arbnode.SyncMonitorConfig
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &ctx)
		if config == nil {
			return
		}

		s := arbnode.NewSyncMonitor(config)
		s.SafeBlockNumber(ctx)
	})
}

func Fuzz_SyncMonitor_SyncProgressMap(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *arbnode.SyncMonitorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		s := arbnode.NewSyncMonitor(config)
		s.SyncProgressMap()
	})
}

func Fuzz_SyncMonitor_Synced(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *arbnode.SyncMonitorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		s := arbnode.NewSyncMonitor(config)
		s.Synced()
	})
}

func Fuzz_TransactionStreamer_AddBroadcastMessages(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var feedMessages []*broadcaster.BroadcastFeedMessage
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &feedMessages)
		if s == nil {
			return
		}

		s.AddBroadcastMessages(feedMessages)
	})
}

func Fuzz_TransactionStreamer_AddFakeInitMessage(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.AddFakeInitMessage()
	})
}

func Fuzz_TransactionStreamer_AddMessages(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var pos arbutil.MessageIndex
		var messagesAreConfirmed bool
		var messages []arbostypes.MessageWithMetadata
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &pos, &messagesAreConfirmed, &messages)
		if s == nil {
			return
		}

		s.AddMessages(pos, messagesAreConfirmed, messages)
	})
}

// skipping Fuzz_TransactionStreamer_AddMessagesAndEndBatch because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Batch

func Fuzz_TransactionStreamer_ExpectChosenSequencer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.ExpectChosenSequencer()
	})
}

func Fuzz_TransactionStreamer_FetchBatch(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var batchNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &batchNum)
		if s == nil {
			return
		}

		s.FetchBatch(batchNum)
	})
}

func Fuzz_TransactionStreamer_GenesisBlockNumber(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.GenesisBlockNumber()
	})
}

func Fuzz_TransactionStreamer_GetMessage(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var seqNum arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &seqNum)
		if s == nil {
			return
		}

		s.GetMessage(seqNum)
	})
}

func Fuzz_TransactionStreamer_GetMessageCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.GetMessageCount()
	})
}

func Fuzz_TransactionStreamer_GetMessageCountSync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var t2 *testing.T
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &t2)
		if s == nil || t2 == nil {
			return
		}

		s.GetMessageCountSync(t2)
	})
}

func Fuzz_TransactionStreamer_GetProcessedMessageCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.GetProcessedMessageCount()
	})
}

func Fuzz_TransactionStreamer_PauseReorgs(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.PauseReorgs()
	})
}

func Fuzz_TransactionStreamer_PopulateFeedBacklog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.PopulateFeedBacklog()
	})
}

func Fuzz_TransactionStreamer_ReorgTo(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var count arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &count)
		if s == nil {
			return
		}

		s.ReorgTo(count)
	})
}

// skipping Fuzz_TransactionStreamer_ReorgToAndEndBatch because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Batch

func Fuzz_TransactionStreamer_ResultAtCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var count arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &count)
		if s == nil {
			return
		}

		s.ResultAtCount(count)
	})
}

func Fuzz_TransactionStreamer_ResumeReorgs(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.ResumeReorgs()
	})
}

func Fuzz_TransactionStreamer_SetBlockValidator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var validator *staker.BlockValidator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &validator)
		if s == nil || validator == nil {
			return
		}

		s.SetBlockValidator(validator)
	})
}

func Fuzz_TransactionStreamer_SetInboxReaders(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var inboxReader *arbnode.InboxReader
		var delayedBridge *arbnode.DelayedBridge
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &inboxReader, &delayedBridge)
		if s == nil || inboxReader == nil || delayedBridge == nil {
			return
		}

		s.SetInboxReaders(inboxReader, delayedBridge)
	})
}

func Fuzz_TransactionStreamer_SetSeqCoordinator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var coordinator *arbnode.SeqCoordinator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &coordinator)
		if s == nil || coordinator == nil {
			return
		}

		s.SetSeqCoordinator(coordinator)
	})
}

func Fuzz_TransactionStreamer_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctxIn)
		if s == nil {
			return
		}

		s.Start(ctxIn)
	})
}

func Fuzz_TransactionStreamer_WriteMessageFromSequencer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *arbnode.TransactionStreamer
		var pos arbutil.MessageIndex
		var msgWithMeta arbostypes.MessageWithMetadata
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &pos, &msgWithMeta)
		if s == nil {
			return
		}

		s.WriteMessageFromSequencer(pos, msgWithMeta)
	})
}

func Fuzz_BatchPosterConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.BatchPosterConfigAddOptions(prefix, f2)
	})
}

func Fuzz_ConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		var feedInputEnable bool
		var feedOutputEnable bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2, &feedInputEnable, &feedOutputEnable)
		if f2 == nil {
			return
		}

		arbnode.ConfigAddOptions(prefix, f2, feedInputEnable, feedOutputEnable)
	})
}

// skipping Fuzz_CreateNode because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Database

func Fuzz_DangerousConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.DangerousConfigAddOptions(prefix, f2)
	})
}

func Fuzz_DelayedSequencerConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.DelayedSequencerConfigAddOptions(prefix, f2)
	})
}

// skipping Fuzz_DeployOnL1 because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

func Fuzz_GenerateRollupConfig(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prod bool
		var wasmModuleRoot common.Hash
		var rollupOwner common.Address
		var chainConfig *params.ChainConfig
		var serializedChainConfig []byte
		var loserStakeEscrow common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prod, &wasmModuleRoot, &rollupOwner, &chainConfig, &serializedChainConfig, &loserStakeEscrow)
		if chainConfig == nil {
			return
		}

		arbnode.GenerateRollupConfig(prod, wasmModuleRoot, rollupOwner, chainConfig, serializedChainConfig, loserStakeEscrow)
	})
}

func Fuzz_InboxReaderConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.InboxReaderConfigAddOptions(prefix, f2)
	})
}

func Fuzz_MaintenanceConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.MaintenanceConfigAddOptions(prefix, f2)
	})
}

func Fuzz_MessagePrunerConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.MessagePrunerConfigAddOptions(prefix, f2)
	})
}

// skipping Fuzz_NewBatchPoster because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Database

// skipping Fuzz_NewClassicOutboxRetriever because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Database

// skipping Fuzz_NewDelayedBridge because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

// skipping Fuzz_NewDelayedSequencer because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbnode.DelayedSequencerConfigFetcher

// skipping Fuzz_NewInboxReader because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

// skipping Fuzz_NewInboxTracker because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Database

// skipping Fuzz_NewMaintenanceRunner because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbnode.MaintenanceConfigFetcher

// skipping Fuzz_NewMessagePruner because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbnode.MessagePrunerConfigFetcher

// skipping Fuzz_NewSeqCoordinator because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/util/signature.DataSignerFunc

// skipping Fuzz_NewSequencerInbox because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

func Fuzz_NewSyncMonitor(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config *arbnode.SyncMonitorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)
		if config == nil {
			return
		}

		arbnode.NewSyncMonitor(config)
	})
}

// skipping Fuzz_NewTransactionStreamer because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Database

func Fuzz_SeqCoordinatorConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.SeqCoordinatorConfigAddOptions(prefix, f2)
	})
}

// skipping Fuzz_StandaloneSeqCoordinatorInvalidateMsgIndex because parameters include func, chan, or unsupported interface: github.com/go-redis/redis/v8.UniversalClient

func Fuzz_SyncMonitorConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.SyncMonitorConfigAddOptions(prefix, f2)
	})
}

func Fuzz_TransactionStreamerConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		arbnode.TransactionStreamerConfigAddOptions(prefix, f2)
	})
}

// skipping Fuzz_ValidatorDataposter because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Database
