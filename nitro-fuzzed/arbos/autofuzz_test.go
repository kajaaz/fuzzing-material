package arbcompressfuzz

// Edit if desired. Code generated by "go-fuzz-fill-utils ./arbos".

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/state"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/ethereum/go-ethereum/params"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/arbos"
	"github.com/offchainlabs/nitro/arbos/arbosState"
)

func Fuzz_L1Info_Equals(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var info *arbos.L1Info
		var o *arbos.L1Info
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&info, &o)
		if info == nil || o == nil {
			return
		}

		info.Equals(o)
	})
}

func Fuzz_L1Info_L1BlockNumber(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var info *arbos.L1Info
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&info)
		if info == nil {
			return
		}

		info.L1BlockNumber()
	})
}

func Fuzz_TxProcessor_DropTip(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.DropTip()
	})
}

func Fuzz_TxProcessor_EndTxHook(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		var gasLeft uint64
		var success bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg, &gasLeft, &success)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.EndTxHook(gasLeft, success)
	})
}

func Fuzz_TxProcessor_FillReceiptInfo(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		var receipt *types.Receipt
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg, &receipt)
		if evm == nil || msg == nil || receipt == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.FillReceiptInfo(receipt)
	})
}

func Fuzz_TxProcessor_ForceRefundGas(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.ForceRefundGas()
	})
}

func Fuzz_TxProcessor_GasChargingHook(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		var gasRemaining *uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg, &gasRemaining)
		if evm == nil || msg == nil || gasRemaining == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.GasChargingHook(gasRemaining)
	})
}

func Fuzz_TxProcessor_GasPriceOp(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e1 *vm.EVM
		var msg *core.Message
		var e3 *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&e1, &msg, &e3)
		if e1 == nil || msg == nil || e3 == nil {
			return
		}

		p := arbos.NewTxProcessor(e1, msg)
		p.GasPriceOp(e3)
	})
}

func Fuzz_TxProcessor_GetPaidGasPrice(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.GetPaidGasPrice()
	})
}

func Fuzz_TxProcessor_L1BlockHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		var blockCtx vm.BlockContext
		var l1BlockNumber uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg, &blockCtx, &l1BlockNumber)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.L1BlockHash(blockCtx, l1BlockNumber)
	})
}

func Fuzz_TxProcessor_L1BlockNumber(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		var blockCtx vm.BlockContext
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg, &blockCtx)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.L1BlockNumber(blockCtx)
	})
}

func Fuzz_TxProcessor_MsgIsNonMutating(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.MsgIsNonMutating()
	})
}

func Fuzz_TxProcessor_NonrefundableGas(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.NonrefundableGas()
	})
}

func Fuzz_TxProcessor_PopCaller(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.PopCaller()
	})
}

func Fuzz_TxProcessor_PushCaller(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg, &addr)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.PushCaller(addr)
	})
}

func Fuzz_TxProcessor_ScheduledTxes(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.ScheduledTxes()
	})
}

func Fuzz_TxProcessor_StartTxHook(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		p := arbos.NewTxProcessor(evm, msg)
		p.StartTxHook()
	})
}

// skipping Fuzz_Engine_APIs because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainHeaderReader

func Fuzz_Engine_Author(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e arbos.Engine
		var header *types.Header
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&e, &header)
		if header == nil {
			return
		}

		e.Author(header)
	})
}

// skipping Fuzz_Engine_CalcDifficulty because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainHeaderReader

func Fuzz_Engine_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e arbos.Engine
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&e)

		e.Close()
	})
}

// skipping Fuzz_Engine_Finalize because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainHeaderReader

// skipping Fuzz_Engine_FinalizeAndAssemble because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainHeaderReader

// skipping Fuzz_Engine_Prepare because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainHeaderReader

// skipping Fuzz_Engine_Seal because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainHeaderReader

func Fuzz_Engine_SealHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e arbos.Engine
		var header *types.Header
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&e, &header)
		if header == nil {
			return
		}

		e.SealHash(header)
	})
}

// skipping Fuzz_Engine_VerifyHeader because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainHeaderReader

// skipping Fuzz_Engine_VerifyHeaders because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainHeaderReader

// skipping Fuzz_Engine_VerifyUncles because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/consensus.ChainReader

func Fuzz_ApplyInternalTxUpdate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var tx *types.ArbitrumInternalTx
		var state *arbosState.ArbosState
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&tx, &state, &evm)
		if tx == nil || state == nil || evm == nil {
			return
		}

		arbos.ApplyInternalTxUpdate(tx, state, evm)
	})
}

func Fuzz_FinalizeBlock(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var header *types.Header
		var txs types.Transactions
		var statedb *state.StateDB
		var chainConfig *params.ChainConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&header, &txs, &statedb, &chainConfig)
		if header == nil || statedb == nil || chainConfig == nil {
			return
		}

		arbos.FinalizeBlock(header, txs, statedb, chainConfig)
	})
}

func Fuzz_GetPosterGas(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var state *arbosState.ArbosState
		var baseFee *big.Int
		var runMode core.MessageRunMode
		var posterCost *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&state, &baseFee, &runMode, &posterCost)
		if state == nil || baseFee == nil || posterCost == nil {
			return
		}

		arbos.GetPosterGas(state, baseFee, runMode, posterCost)
	})
}

func Fuzz_InternalTxStartBlock(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var chainId *big.Int
		var l1BaseFee *big.Int
		var l1BlockNum uint64
		var header *types.Header
		var lastHeader *types.Header
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&chainId, &l1BaseFee, &l1BlockNum, &header, &lastHeader)
		if chainId == nil || l1BaseFee == nil || header == nil || lastHeader == nil {
			return
		}

		arbos.InternalTxStartBlock(chainId, l1BaseFee, l1BlockNum, header, lastHeader)
	})
}

func Fuzz_NewTxProcessor(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var evm *vm.EVM
		var msg *core.Message
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&evm, &msg)
		if evm == nil || msg == nil {
			return
		}

		arbos.NewTxProcessor(evm, msg)
	})
}

// skipping Fuzz_ParseL2Transactions because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbos.InfallibleBatchFetcher

// skipping Fuzz_ProduceBlock because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/core.ChainContext

// skipping Fuzz_ProduceBlockAdvanced because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/core.ChainContext
