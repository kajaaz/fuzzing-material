package arbcompressfuzz

// Edit if desired. Code generated by "go-fuzz-fill-utils ./precompiles/".

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/precompiles"
)

func Fuzz_ArbSys_ArbBlockHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		var arbBlockNumber *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &arbBlockNumber)
		if con == nil || c == nil || evm == nil || arbBlockNumber == nil {
			return
		}

		con.ArbBlockHash(c, evm, arbBlockNumber)
	})
}

func Fuzz_ArbSys_ArbBlockNumber(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if con == nil || c == nil || evm == nil {
			return
		}

		con.ArbBlockNumber(c, evm)
	})
}

func Fuzz_ArbSys_ArbChainID(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if con == nil || c == nil || evm == nil {
			return
		}

		con.ArbChainID(c, evm)
	})
}

func Fuzz_ArbSys_ArbOSVersion(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if con == nil || c == nil || evm == nil {
			return
		}

		con.ArbOSVersion(c, evm)
	})
}

func Fuzz_ArbSys_GetStorageGasAvailable(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if con == nil || c == nil || evm == nil {
			return
		}

		con.GetStorageGasAvailable(c, evm)
	})
}

func Fuzz_ArbSys_IsTopLevelCall(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if con == nil || c == nil || evm == nil {
			return
		}

		con.IsTopLevelCall(c, evm)
	})
}

func Fuzz_ArbSys_MapL1SenderContractAddressToL2Alias(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var sender common.Address
		var dest common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &sender, &dest)
		if con == nil || c == nil {
			return
		}

		con.MapL1SenderContractAddressToL2Alias(c, sender, dest)
	})
}

func Fuzz_ArbSys_MyCallersAddressWithoutAliasing(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if con == nil || c == nil || evm == nil {
			return
		}

		con.MyCallersAddressWithoutAliasing(c, evm)
	})
}

func Fuzz_ArbSys_SendTxToL1(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		var value *big.Int
		var destination common.Address
		var calldataForL1 []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &value, &destination, &calldataForL1)
		if con == nil || c == nil || evm == nil || value == nil {
			return
		}

		con.SendTxToL1(c, evm, value, destination, calldataForL1)
	})
}

func Fuzz_ArbSys_WasMyCallersAddressAliased(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con *precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if con == nil || c == nil || evm == nil {
			return
		}

		con.WasMyCallersAddressAliased(c, evm)
	})
}

func Fuzz_Context_Burn(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *precompiles.Context
		var amount uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &amount)
		if c == nil {
			return
		}

		c.Burn(amount)
	})
}

func Fuzz_Context_Burned(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *precompiles.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.Burned()
	})
}

// skipping Fuzz_Context_HandleError because parameters include func, chan, or unsupported interface: error

func Fuzz_Context_ReadOnly(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *precompiles.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.ReadOnly()
	})
}

// skipping Fuzz_Context_Restrict because parameters include func, chan, or unsupported interface: error

func Fuzz_Context_TracingInfo(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *precompiles.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.TracingInfo()
	})
}

func Fuzz_DebugPrecompile_Call(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var wrapper *precompiles.DebugPrecompile
		var input []byte
		var precompileAddress common.Address
		var actingAsAddress common.Address
		var caller common.Address
		var value *big.Int
		var readOnly bool
		var gasSupplied uint64
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&wrapper, &input, &precompileAddress, &actingAsAddress, &caller, &value, &readOnly, &gasSupplied, &evm)
		if wrapper == nil || value == nil || evm == nil {
			return
		}

		wrapper.Call(input, precompileAddress, actingAsAddress, caller, value, readOnly, gasSupplied, evm)
	})
}

func Fuzz_DebugPrecompile_Precompile(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var wrapper *precompiles.DebugPrecompile
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&wrapper)
		if wrapper == nil {
			return
		}

		wrapper.Precompile()
	})
}

func Fuzz_OwnerPrecompile_Call(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var wrapper *precompiles.OwnerPrecompile
		var input []byte
		var precompileAddress common.Address
		var actingAsAddress common.Address
		var caller common.Address
		var value *big.Int
		var readOnly bool
		var gasSupplied uint64
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&wrapper, &input, &precompileAddress, &actingAsAddress, &caller, &value, &readOnly, &gasSupplied, &evm)
		if wrapper == nil || value == nil || evm == nil {
			return
		}

		wrapper.Call(input, precompileAddress, actingAsAddress, caller, value, readOnly, gasSupplied, evm)
	})
}

func Fuzz_OwnerPrecompile_Precompile(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var wrapper *precompiles.OwnerPrecompile
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&wrapper)
		if wrapper == nil {
			return
		}

		wrapper.Precompile()
	})
}

func Fuzz_Precompile_Call(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var p *precompiles.Precompile
		var input []byte
		var precompileAddress common.Address
		var actingAsAddress common.Address
		var caller common.Address
		var value *big.Int
		var readOnly bool
		var gasSupplied uint64
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&p, &input, &precompileAddress, &actingAsAddress, &caller, &value, &readOnly, &gasSupplied, &evm)
		if p == nil || value == nil || evm == nil {
			return
		}

		p.Call(input, precompileAddress, actingAsAddress, caller, value, readOnly, gasSupplied, evm)
	})
}

// skipping Fuzz_Precompile_CloneWithImpl because parameters include func, chan, or unsupported interface: interface{}

func Fuzz_Precompile_Get4ByteMethodSignatures(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var p *precompiles.Precompile
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&p)
		if p == nil {
			return
		}

		p.Get4ByteMethodSignatures()
	})
}

func Fuzz_Precompile_GetErrorABIs(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var p *precompiles.Precompile
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&p)
		if p == nil {
			return
		}

		p.GetErrorABIs()
	})
}

func Fuzz_Precompile_GetMethodID(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var p *precompiles.Precompile
		var name string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&p, &name)
		if p == nil {
			return
		}

		p.GetMethodID(name)
	})
}

func Fuzz_Precompile_Precompile(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var p *precompiles.Precompile
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&p)
		if p == nil {
			return
		}

		p.Precompile()
	})
}

func Fuzz_SolError_Error(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var e *precompiles.SolError
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&e)
		if e == nil {
			return
		}

		e.Error()
	})
}

func Fuzz_ArbAddressTable_AddressExists(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAddressTable
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.AddressExists(c, evm, addr)
	})
}

func Fuzz_ArbAddressTable_Compress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAddressTable
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.Compress(c, evm, addr)
	})
}

func Fuzz_ArbAddressTable_Decompress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAddressTable
		var c *precompiles.Context
		var evm *vm.EVM
		var buf []uint8
		var offset *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &buf, &offset)
		if c == nil || evm == nil || offset == nil {
			return
		}

		con.Decompress(c, evm, buf, offset)
	})
}

func Fuzz_ArbAddressTable_Lookup(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAddressTable
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.Lookup(c, evm, addr)
	})
}

func Fuzz_ArbAddressTable_LookupIndex(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAddressTable
		var c *precompiles.Context
		var evm *vm.EVM
		var index *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &index)
		if c == nil || evm == nil || index == nil {
			return
		}

		con.LookupIndex(c, evm, index)
	})
}

func Fuzz_ArbAddressTable_Register(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAddressTable
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.Register(c, evm, addr)
	})
}

func Fuzz_ArbAddressTable_Size(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAddressTable
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.Size(c, evm)
	})
}

func Fuzz_ArbAggregator_AddBatchPoster(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAggregator
		var c *precompiles.Context
		var evm *vm.EVM
		var newBatchPoster common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &newBatchPoster)
		if c == nil || evm == nil {
			return
		}

		con.AddBatchPoster(c, evm, newBatchPoster)
	})
}

func Fuzz_ArbAggregator_GetBatchPosters(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAggregator
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetBatchPosters(c, evm)
	})
}

func Fuzz_ArbAggregator_GetDefaultAggregator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAggregator
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetDefaultAggregator(c, evm)
	})
}

func Fuzz_ArbAggregator_GetFeeCollector(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAggregator
		var c *precompiles.Context
		var evm *vm.EVM
		var batchPoster common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &batchPoster)
		if c == nil || evm == nil {
			return
		}

		con.GetFeeCollector(c, evm, batchPoster)
	})
}

func Fuzz_ArbAggregator_GetPreferredAggregator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAggregator
		var c *precompiles.Context
		var evm *vm.EVM
		var address common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &address)
		if c == nil || evm == nil {
			return
		}

		con.GetPreferredAggregator(c, evm, address)
	})
}

func Fuzz_ArbAggregator_GetTxBaseFee(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAggregator
		var c *precompiles.Context
		var evm *vm.EVM
		var aggregator common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &aggregator)
		if c == nil || evm == nil {
			return
		}

		con.GetTxBaseFee(c, evm, aggregator)
	})
}

func Fuzz_ArbAggregator_SetFeeCollector(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAggregator
		var c *precompiles.Context
		var evm *vm.EVM
		var batchPoster common.Address
		var newFeeCollector common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &batchPoster, &newFeeCollector)
		if c == nil || evm == nil {
			return
		}

		con.SetFeeCollector(c, evm, batchPoster, newFeeCollector)
	})
}

func Fuzz_ArbAggregator_SetTxBaseFee(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbAggregator
		var c *precompiles.Context
		var evm *vm.EVM
		var aggregator common.Address
		var feeInL1Gas *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &aggregator, &feeInL1Gas)
		if c == nil || evm == nil || feeInL1Gas == nil {
			return
		}

		con.SetTxBaseFee(c, evm, aggregator, feeInL1Gas)
	})
}

func Fuzz_ArbDebug_BecomeChainOwner(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbDebug
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.BecomeChainOwner(c, evm)
	})
}

func Fuzz_ArbDebug_CustomRevert(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbDebug
		var c *precompiles.Context
		var number uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &number)
		if c == nil {
			return
		}

		con.CustomRevert(c, number)
	})
}

func Fuzz_ArbDebug_Events(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbDebug
		var c *precompiles.Context
		var evm *vm.EVM
		var paid *big.Int
		var flag bool
		var value [32]byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &paid, &flag, &value)
		if c == nil || evm == nil || paid == nil {
			return
		}

		con.Events(c, evm, paid, flag, value)
	})
}

func Fuzz_ArbDebug_EventsView(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbDebug
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.EventsView(c, evm)
	})
}

func Fuzz_ArbDebug_LegacyError(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbDebug
		var c *precompiles.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c)
		if c == nil {
			return
		}

		con.LegacyError(c)
	})
}

func Fuzz_ArbFunctionTable_Get(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbFunctionTable
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		var index *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr, &index)
		if c == nil || evm == nil || index == nil {
			return
		}

		con.Get(c, evm, addr, index)
	})
}

func Fuzz_ArbFunctionTable_Size(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbFunctionTable
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.Size(c, evm, addr)
	})
}

func Fuzz_ArbFunctionTable_Upload(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbFunctionTable
		var c *precompiles.Context
		var evm *vm.EVM
		var buf []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &buf)
		if c == nil || evm == nil {
			return
		}

		con.Upload(c, evm, buf)
	})
}

func Fuzz_ArbGasInfo_GetAmortizedCostCapBips(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetAmortizedCostCapBips(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetCurrentTxL1GasFees(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetCurrentTxL1GasFees(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetGasAccountingParams(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetGasAccountingParams(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetGasBacklog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetGasBacklog(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetGasBacklogTolerance(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetGasBacklogTolerance(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetL1BaseFeeEstimate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetL1BaseFeeEstimate(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetL1BaseFeeEstimateInertia(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetL1BaseFeeEstimateInertia(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetL1FeesAvailable(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetL1FeesAvailable(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetL1GasPriceEstimate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetL1GasPriceEstimate(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetL1PricingSurplus(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetL1PricingSurplus(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetL1RewardRate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetL1RewardRate(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetL1RewardRecipient(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetL1RewardRecipient(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetMinimumGasPrice(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetMinimumGasPrice(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetPerBatchGasCharge(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetPerBatchGasCharge(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetPricesInArbGas(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetPricesInArbGas(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetPricesInArbGasWithAggregator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		var aggregator common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &aggregator)
		if c == nil || evm == nil {
			return
		}

		con.GetPricesInArbGasWithAggregator(c, evm, aggregator)
	})
}

func Fuzz_ArbGasInfo_GetPricesInWei(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetPricesInWei(c, evm)
	})
}

func Fuzz_ArbGasInfo_GetPricesInWeiWithAggregator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		var aggregator common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &aggregator)
		if c == nil || evm == nil {
			return
		}

		con.GetPricesInWeiWithAggregator(c, evm, aggregator)
	})
}

func Fuzz_ArbGasInfo_GetPricingInertia(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbGasInfo
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetPricingInertia(c, evm)
	})
}

func Fuzz_ArbInfo_GetBalance(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbInfo
		var c *precompiles.Context
		var evm *vm.EVM
		var account common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &account)
		if c == nil || evm == nil {
			return
		}

		con.GetBalance(c, evm, account)
	})
}

func Fuzz_ArbInfo_GetCode(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbInfo
		var c *precompiles.Context
		var evm *vm.EVM
		var account common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &account)
		if c == nil || evm == nil {
			return
		}

		con.GetCode(c, evm, account)
	})
}

func Fuzz_ArbOwner_AddChainOwner(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var newOwner common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &newOwner)
		if c == nil || evm == nil {
			return
		}

		con.AddChainOwner(c, evm, newOwner)
	})
}

func Fuzz_ArbOwner_GetAllChainOwners(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetAllChainOwners(c, evm)
	})
}

func Fuzz_ArbOwner_GetInfraFeeAccount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetInfraFeeAccount(c, evm)
	})
}

func Fuzz_ArbOwner_GetNetworkFeeAccount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetNetworkFeeAccount(c, evm)
	})
}

func Fuzz_ArbOwner_IsChainOwner(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.IsChainOwner(c, evm, addr)
	})
}

func Fuzz_ArbOwner_ReleaseL1PricerSurplusFunds(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var maxWeiToRelease *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &maxWeiToRelease)
		if c == nil || evm == nil || maxWeiToRelease == nil {
			return
		}

		con.ReleaseL1PricerSurplusFunds(c, evm, maxWeiToRelease)
	})
}

func Fuzz_ArbOwner_RemoveChainOwner(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.RemoveChainOwner(c, evm, addr)
	})
}

func Fuzz_ArbOwner_ScheduleArbOSUpgrade(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var newVersion uint64
		var timestamp uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &newVersion, &timestamp)
		if c == nil || evm == nil {
			return
		}

		con.ScheduleArbOSUpgrade(c, evm, newVersion, timestamp)
	})
}

func Fuzz_ArbOwner_SetAmortizedCostCapBips(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var cap uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &cap)
		if c == nil || evm == nil {
			return
		}

		con.SetAmortizedCostCapBips(c, evm, cap)
	})
}

func Fuzz_ArbOwner_SetChainConfig(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var serializedChainConfig []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &serializedChainConfig)
		if c == nil || evm == nil {
			return
		}

		con.SetChainConfig(c, evm, serializedChainConfig)
	})
}

func Fuzz_ArbOwner_SetInfraFeeAccount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var newNetworkFeeAccount common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &newNetworkFeeAccount)
		if c == nil || evm == nil {
			return
		}

		con.SetInfraFeeAccount(c, evm, newNetworkFeeAccount)
	})
}

func Fuzz_ArbOwner_SetL1BaseFeeEstimateInertia(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var inertia uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &inertia)
		if c == nil || evm == nil {
			return
		}

		con.SetL1BaseFeeEstimateInertia(c, evm, inertia)
	})
}

func Fuzz_ArbOwner_SetL1PricePerUnit(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var pricePerUnit *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &pricePerUnit)
		if c == nil || evm == nil || pricePerUnit == nil {
			return
		}

		con.SetL1PricePerUnit(c, evm, pricePerUnit)
	})
}

func Fuzz_ArbOwner_SetL1PricingEquilibrationUnits(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var equilibrationUnits *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &equilibrationUnits)
		if c == nil || evm == nil || equilibrationUnits == nil {
			return
		}

		con.SetL1PricingEquilibrationUnits(c, evm, equilibrationUnits)
	})
}

func Fuzz_ArbOwner_SetL1PricingInertia(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var inertia uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &inertia)
		if c == nil || evm == nil {
			return
		}

		con.SetL1PricingInertia(c, evm, inertia)
	})
}

func Fuzz_ArbOwner_SetL1PricingRewardRate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var weiPerUnit uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &weiPerUnit)
		if c == nil || evm == nil {
			return
		}

		con.SetL1PricingRewardRate(c, evm, weiPerUnit)
	})
}

func Fuzz_ArbOwner_SetL1PricingRewardRecipient(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var recipient common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &recipient)
		if c == nil || evm == nil {
			return
		}

		con.SetL1PricingRewardRecipient(c, evm, recipient)
	})
}

func Fuzz_ArbOwner_SetL2BaseFee(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var priceInWei *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &priceInWei)
		if c == nil || evm == nil || priceInWei == nil {
			return
		}

		con.SetL2BaseFee(c, evm, priceInWei)
	})
}

func Fuzz_ArbOwner_SetL2GasBacklogTolerance(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var sec uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &sec)
		if c == nil || evm == nil {
			return
		}

		con.SetL2GasBacklogTolerance(c, evm, sec)
	})
}

func Fuzz_ArbOwner_SetL2GasPricingInertia(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var sec uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &sec)
		if c == nil || evm == nil {
			return
		}

		con.SetL2GasPricingInertia(c, evm, sec)
	})
}

func Fuzz_ArbOwner_SetMaxTxGasLimit(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var limit uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &limit)
		if c == nil || evm == nil {
			return
		}

		con.SetMaxTxGasLimit(c, evm, limit)
	})
}

func Fuzz_ArbOwner_SetMinimumL2BaseFee(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var priceInWei *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &priceInWei)
		if c == nil || evm == nil || priceInWei == nil {
			return
		}

		con.SetMinimumL2BaseFee(c, evm, priceInWei)
	})
}

func Fuzz_ArbOwner_SetNetworkFeeAccount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var newNetworkFeeAccount common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &newNetworkFeeAccount)
		if c == nil || evm == nil {
			return
		}

		con.SetNetworkFeeAccount(c, evm, newNetworkFeeAccount)
	})
}

func Fuzz_ArbOwner_SetPerBatchGasCharge(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var cost int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &cost)
		if c == nil || evm == nil {
			return
		}

		con.SetPerBatchGasCharge(c, evm, cost)
	})
}

func Fuzz_ArbOwner_SetSpeedLimit(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwner
		var c *precompiles.Context
		var evm *vm.EVM
		var limit uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &limit)
		if c == nil || evm == nil {
			return
		}

		con.SetSpeedLimit(c, evm, limit)
	})
}

func Fuzz_ArbOwnerPublic_GetAllChainOwners(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwnerPublic
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetAllChainOwners(c, evm)
	})
}

func Fuzz_ArbOwnerPublic_GetInfraFeeAccount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwnerPublic
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetInfraFeeAccount(c, evm)
	})
}

func Fuzz_ArbOwnerPublic_GetNetworkFeeAccount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwnerPublic
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetNetworkFeeAccount(c, evm)
	})
}

func Fuzz_ArbOwnerPublic_IsChainOwner(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwnerPublic
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.IsChainOwner(c, evm, addr)
	})
}

func Fuzz_ArbOwnerPublic_RectifyChainOwner(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbOwnerPublic
		var c *precompiles.Context
		var evm *vm.EVM
		var addr common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &addr)
		if c == nil || evm == nil {
			return
		}

		con.RectifyChainOwner(c, evm, addr)
	})
}

func Fuzz_ArbRetryableTx_Cancel(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbRetryableTx
		var c *precompiles.Context
		var evm *vm.EVM
		var ticketId [32]byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &ticketId)
		if c == nil || evm == nil {
			return
		}

		con.Cancel(c, evm, ticketId)
	})
}

func Fuzz_ArbRetryableTx_GetBeneficiary(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbRetryableTx
		var c *precompiles.Context
		var evm *vm.EVM
		var ticketId [32]byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &ticketId)
		if c == nil || evm == nil {
			return
		}

		con.GetBeneficiary(c, evm, ticketId)
	})
}

func Fuzz_ArbRetryableTx_GetCurrentRedeemer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbRetryableTx
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetCurrentRedeemer(c, evm)
	})
}

func Fuzz_ArbRetryableTx_GetLifetime(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbRetryableTx
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetLifetime(c, evm)
	})
}

func Fuzz_ArbRetryableTx_GetTimeout(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbRetryableTx
		var c *precompiles.Context
		var evm *vm.EVM
		var ticketId [32]byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &ticketId)
		if c == nil || evm == nil {
			return
		}

		con.GetTimeout(c, evm, ticketId)
	})
}

func Fuzz_ArbRetryableTx_Keepalive(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbRetryableTx
		var c *precompiles.Context
		var evm *vm.EVM
		var ticketId [32]byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &ticketId)
		if c == nil || evm == nil {
			return
		}

		con.Keepalive(c, evm, ticketId)
	})
}

func Fuzz_ArbRetryableTx_Redeem(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbRetryableTx
		var c *precompiles.Context
		var evm *vm.EVM
		var ticketId [32]byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &ticketId)
		if c == nil || evm == nil {
			return
		}

		con.Redeem(c, evm, ticketId)
	})
}

func Fuzz_ArbRetryableTx_SubmitRetryable(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbRetryableTx
		var c *precompiles.Context
		var evm *vm.EVM
		var requestId [32]byte
		var l1BaseFee *big.Int
		var deposit *big.Int
		var callvalue *big.Int
		var gasFeeCap *big.Int
		var gasLimit uint64
		var maxSubmissionFee *big.Int
		var feeRefundAddress common.Address
		var beneficiary common.Address
		var retryTo common.Address
		var retryData []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &requestId, &l1BaseFee, &deposit, &callvalue, &gasFeeCap, &gasLimit, &maxSubmissionFee, &feeRefundAddress, &beneficiary, &retryTo, &retryData)
		if c == nil || evm == nil || l1BaseFee == nil || deposit == nil || callvalue == nil || gasFeeCap == nil || maxSubmissionFee == nil {
			return
		}

		con.SubmitRetryable(c, evm, requestId, l1BaseFee, deposit, callvalue, gasFeeCap, gasLimit, maxSubmissionFee, feeRefundAddress, beneficiary, retryTo, retryData)
	})
}

func Fuzz_ArbStatistics_GetStats(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbStatistics
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.GetStats(c, evm)
	})
}

func Fuzz_ArbSys_SendMerkleTreeState(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm)
		if c == nil || evm == nil {
			return
		}

		con.SendMerkleTreeState(c, evm)
	})
}

func Fuzz_ArbSys_WithdrawEth(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbSys
		var c *precompiles.Context
		var evm *vm.EVM
		var value *big.Int
		var destination common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &value, &destination)
		if c == nil || evm == nil || value == nil {
			return
		}

		con.WithdrawEth(c, evm, value, destination)
	})
}

func Fuzz_ArbosActs_BatchPostingReport(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbosActs
		var c *precompiles.Context
		var evm *vm.EVM
		var batchTimestamp *big.Int
		var batchPosterAddress common.Address
		var batchNumber uint64
		var batchDataGas uint64
		var l1BaseFeeWei *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &batchTimestamp, &batchPosterAddress, &batchNumber, &batchDataGas, &l1BaseFeeWei)
		if c == nil || evm == nil || batchTimestamp == nil || l1BaseFeeWei == nil {
			return
		}

		con.BatchPostingReport(c, evm, batchTimestamp, batchPosterAddress, batchNumber, batchDataGas, l1BaseFeeWei)
	})
}

func Fuzz_ArbosActs_StartBlock(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbosActs
		var c *precompiles.Context
		var evm *vm.EVM
		var l1BaseFee *big.Int
		var l1BlockNumber uint64
		var l2BlockNumber uint64
		var timeLastBlock uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &evm, &l1BaseFee, &l1BlockNumber, &l2BlockNumber, &timeLastBlock)
		if c == nil || evm == nil || l1BaseFee == nil {
			return
		}

		con.StartBlock(c, evm, l1BaseFee, l1BlockNumber, l2BlockNumber, timeLastBlock)
	})
}

func Fuzz_ArbosTest_BurnArbGas(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var con precompiles.ArbosTest
		var c *precompiles.Context
		var gasAmount *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&con, &c, &gasAmount)
		if c == nil || gasAmount == nil {
			return
		}

		con.BurnArbGas(c, gasAmount)
	})
}

// skipping Fuzz_MakePrecompile because parameters include func, chan, or unsupported interface: interface{}

func Fuzz_RenderSolError(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var solErr abi.Error
		var d2 []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&solErr, &d2)

		precompiles.RenderSolError(solErr, d2)
	})
}
