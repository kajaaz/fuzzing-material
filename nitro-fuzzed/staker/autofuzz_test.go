package arbcompressfuzz

// Edit if desired. Code generated by "go-fuzz-fill-utils ./staker/".

import (
	"context"
	"math/big"
	"testing"
	"time"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/arbutil"
	"github.com/offchainlabs/nitro/solgen/go/rollupgen"
	"github.com/offchainlabs/nitro/staker"
	"github.com/offchainlabs/nitro/validator"
	"github.com/spf13/pflag"
)

func Fuzz_Assertion_AsSolidityStruct(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var assertion rollupgen.Assertion
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&assertion)

		a := staker.NewAssertionFromSolidity(assertion)
		a.AsSolidityStruct()
	})
}

func Fuzz_Assertion_ExecutionHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var assertion rollupgen.Assertion
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&assertion)

		a := staker.NewAssertionFromSolidity(assertion)
		a.ExecutionHash()
	})
}

func Fuzz_BlockChallengeBackend_FindGlobalStateFromMessageCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.BlockChallengeBackend
		var count arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &count)
		if b == nil {
			return
		}

		b.FindGlobalStateFromMessageCount(count)
	})
}

func Fuzz_BlockChallengeBackend_GetHashAtStep(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.BlockChallengeBackend
		var _x2 context.Context
		var position uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &_x2, &position)
		if b == nil {
			return
		}

		b.GetHashAtStep(_x2, position)
	})
}

func Fuzz_BlockChallengeBackend_GetInfoAtStep(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.BlockChallengeBackend
		var step uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &step)
		if b == nil {
			return
		}

		b.GetInfoAtStep(step)
	})
}

func Fuzz_BlockChallengeBackend_GetMessageCountAtStep(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.BlockChallengeBackend
		var step uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &step)
		if b == nil {
			return
		}

		b.GetMessageCountAtStep(step)
	})
}

func Fuzz_BlockChallengeBackend_IssueExecChallenge(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.BlockChallengeBackend
		var core *staker.challengeCore
		var oldState *staker.ChallengeState
		var startSegment int
		var numsteps uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &core, &oldState, &startSegment, &numsteps)
		if b == nil || core == nil || oldState == nil {
			return
		}

		b.IssueExecChallenge(core, oldState, startSegment, numsteps)
	})
}

func Fuzz_BlockChallengeBackend_SetRange(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.BlockChallengeBackend
		var _x2 context.Context
		var start uint64
		var end uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &_x2, &start, &end)
		if b == nil {
			return
		}

		b.SetRange(_x2, start, end)
	})
}

func Fuzz_BlockValidator_InitAssumeValid(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var globalState validator.GoGlobalState
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &globalState)
		if v == nil {
			return
		}

		v.InitAssumeValid(globalState)
	})
}

func Fuzz_BlockValidator_Initialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx)
		if v == nil {
			return
		}

		v.Initialize(ctx)
	})
}

func Fuzz_BlockValidator_LaunchWorkthreadsWhenCaughtUp(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx)
		if v == nil {
			return
		}

		v.LaunchWorkthreadsWhenCaughtUp(ctx)
	})
}

func Fuzz_BlockValidator_ReadLastValidatedInfo(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.ReadLastValidatedInfo()
	})
}

func Fuzz_BlockValidator_Reorg(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var ctx context.Context
		var count arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx, &count)
		if v == nil {
			return
		}

		v.Reorg(ctx, count)
	})
}

func Fuzz_BlockValidator_ReorgToBatchCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var count uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &count)
		if v == nil {
			return
		}

		v.ReorgToBatchCount(count)
	})
}

func Fuzz_BlockValidator_SetCurrentWasmModuleRoot(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &hash)
		if v == nil {
			return
		}

		v.SetCurrentWasmModuleRoot(hash)
	})
}

func Fuzz_BlockValidator_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctxIn)
		if v == nil {
			return
		}

		v.Start(ctxIn)
	})
}

func Fuzz_BlockValidator_StopAndWait(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.StopAndWait()
	})
}

func Fuzz_BlockValidator_UpdateLatestStaked(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var count arbutil.MessageIndex
		var globalState validator.GoGlobalState
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &count, &globalState)
		if v == nil {
			return
		}

		v.UpdateLatestStaked(count, globalState)
	})
}

func Fuzz_BlockValidator_Validated(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var t2 *testing.T
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &t2)
		if v == nil || t2 == nil {
			return
		}

		v.Validated(t2)
	})
}

func Fuzz_BlockValidator_WaitForPos(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.BlockValidator
		var t2 *testing.T
		var ctx context.Context
		var pos arbutil.MessageIndex
		var timeout time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &t2, &ctx, &pos, &timeout)
		if v == nil || t2 == nil {
			return
		}

		v.WaitForPos(t2, ctx, pos, timeout)
	})
}

func Fuzz_BlockValidatorConfig_Validate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *staker.BlockValidatorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.Validate()
	})
}

func Fuzz_ChallengeManager_Act(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *staker.ChallengeManager
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx)
		if m == nil {
			return
		}

		m.Act(ctx)
	})
}

func Fuzz_ChallengeManager_ChallengeIndex(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *staker.ChallengeManager
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m)
		if m == nil {
			return
		}

		m.ChallengeIndex()
	})
}

func Fuzz_ChallengeManager_GetChallengeState(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *staker.ChallengeManager
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx)
		if m == nil {
			return
		}

		m.GetChallengeState(ctx)
	})
}

func Fuzz_ChallengeManager_IsMyTurn(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *staker.ChallengeManager
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx)
		if m == nil {
			return
		}

		m.IsMyTurn(ctx)
	})
}

func Fuzz_ChallengeManager_IssueOneStepProof(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *staker.ChallengeManager
		var ctx context.Context
		var oldState *staker.ChallengeState
		var startSegment int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx, &oldState, &startSegment)
		if m == nil || oldState == nil {
			return
		}

		m.IssueOneStepProof(ctx, oldState, startSegment)
	})
}

func Fuzz_ChallengeManager_LoadExecChallengeIfExists(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *staker.ChallengeManager
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx)
		if m == nil {
			return
		}

		m.LoadExecChallengeIfExists(ctx)
	})
}

// skipping Fuzz_ChallengeManager_ScanChallengeState because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.ChallengeBackend

func Fuzz_ContractValidatorWallet_Address(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.Address()
	})
}

func Fuzz_ContractValidatorWallet_AddressOrZero(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.AddressOrZero()
	})
}

func Fuzz_ContractValidatorWallet_AuthIfEoa(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.AuthIfEoa()
	})
}

func Fuzz_ContractValidatorWallet_CanBatchTxs(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.CanBatchTxs()
	})
}

func Fuzz_ContractValidatorWallet_ChallengeManagerAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.ChallengeManagerAddress()
	})
}

func Fuzz_ContractValidatorWallet_DataPoster(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b)
		if b == nil {
			return
		}

		b.DataPoster()
	})
}

func Fuzz_ContractValidatorWallet_ExecuteTransactions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		var ctx context.Context
		var builder *staker.ValidatorTxBuilder
		var gasRefunder common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx, &builder, &gasRefunder)
		if v == nil || builder == nil {
			return
		}

		v.ExecuteTransactions(ctx, builder, gasRefunder)
	})
}

func Fuzz_ContractValidatorWallet_From(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.From()
	})
}

func Fuzz_ContractValidatorWallet_Initialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx)
		if v == nil {
			return
		}

		v.Initialize(ctx)
	})
}

func Fuzz_ContractValidatorWallet_L1Client(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.L1Client()
	})
}

func Fuzz_ContractValidatorWallet_RollupAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.RollupAddress()
	})
}

func Fuzz_ContractValidatorWallet_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.ContractValidatorWallet
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ctx)
		if w == nil {
			return
		}

		w.Start(ctx)
	})
}

func Fuzz_ContractValidatorWallet_StopAndWait(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b)
		if b == nil {
			return
		}

		b.StopAndWait()
	})
}

func Fuzz_ContractValidatorWallet_TestTransactions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		var ctx context.Context
		var txs []*types.Transaction
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx, &txs)
		if v == nil {
			return
		}

		v.TestTransactions(ctx, txs)
	})
}

func Fuzz_ContractValidatorWallet_TimeoutChallenges(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		var ctx context.Context
		var challenges []uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx, &challenges)
		if v == nil {
			return
		}

		v.TimeoutChallenges(ctx, challenges)
	})
}

func Fuzz_ContractValidatorWallet_TxSenderAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.ContractValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.TxSenderAddress()
	})
}

func Fuzz_EoaValidatorWallet_Address(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.Address()
	})
}

func Fuzz_EoaValidatorWallet_AddressOrZero(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.AddressOrZero()
	})
}

func Fuzz_EoaValidatorWallet_AuthIfEoa(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.AuthIfEoa()
	})
}

func Fuzz_EoaValidatorWallet_CanBatchTxs(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.CanBatchTxs()
	})
}

func Fuzz_EoaValidatorWallet_ChallengeManagerAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.ChallengeManagerAddress()
	})
}

func Fuzz_EoaValidatorWallet_DataPoster(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b)
		if b == nil {
			return
		}

		b.DataPoster()
	})
}

func Fuzz_EoaValidatorWallet_ExecuteTransactions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		var ctx context.Context
		var builder *staker.ValidatorTxBuilder
		var _x4 common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ctx, &builder, &_x4)
		if w == nil || builder == nil {
			return
		}

		w.ExecuteTransactions(ctx, builder, _x4)
	})
}

func Fuzz_EoaValidatorWallet_Initialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ctx)
		if w == nil {
			return
		}

		w.Initialize(ctx)
	})
}

func Fuzz_EoaValidatorWallet_L1Client(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.L1Client()
	})
}

func Fuzz_EoaValidatorWallet_RollupAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.RollupAddress()
	})
}

func Fuzz_EoaValidatorWallet_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ctx)
		if w == nil {
			return
		}

		w.Start(ctx)
	})
}

func Fuzz_EoaValidatorWallet_StopAndWait(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b)
		if b == nil {
			return
		}

		b.StopAndWait()
	})
}

func Fuzz_EoaValidatorWallet_TestTransactions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		var _x2 context.Context
		var _x3 []*types.Transaction
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &_x2, &_x3)
		if w == nil {
			return
		}

		w.TestTransactions(_x2, _x3)
	})
}

func Fuzz_EoaValidatorWallet_TimeoutChallenges(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		var ctx context.Context
		var timeouts []uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ctx, &timeouts)
		if w == nil {
			return
		}

		w.TimeoutChallenges(ctx, timeouts)
	})
}

func Fuzz_EoaValidatorWallet_TxSenderAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *staker.EoaValidatorWallet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.TxSenderAddress()
	})
}

func Fuzz_ExecutionChallengeBackend_GetFinalState(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ExecutionChallengeBackend
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx)
		if b == nil {
			return
		}

		b.GetFinalState(ctx)
	})
}

func Fuzz_ExecutionChallengeBackend_GetHashAtStep(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ExecutionChallengeBackend
		var ctx context.Context
		var position uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx, &position)
		if b == nil {
			return
		}

		b.GetHashAtStep(ctx, position)
	})
}

func Fuzz_ExecutionChallengeBackend_GetProofAt(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ExecutionChallengeBackend
		var ctx context.Context
		var position uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx, &position)
		if b == nil {
			return
		}

		b.GetProofAt(ctx, position)
	})
}

func Fuzz_ExecutionChallengeBackend_SetRange(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ExecutionChallengeBackend
		var ctx context.Context
		var start uint64
		var end uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx, &start, &end)
		if b == nil {
			return
		}

		b.SetRange(ctx, start, end)
	})
}

func Fuzz_L1Validator_Initialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.L1Validator
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx)
		if v == nil {
			return
		}

		v.Initialize(ctx)
	})
}

func Fuzz_L1ValidatorConfig_ParseStrategy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *staker.L1ValidatorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.ParseStrategy()
	})
}

func Fuzz_L1ValidatorConfig_Validate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *staker.L1ValidatorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.Validate()
	})
}

func Fuzz_L1ValidatorConfig_ValidatorRequired(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *staker.L1ValidatorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.ValidatorRequired()
	})
}

func Fuzz_NodeInfo_AfterState(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n *staker.NodeInfo
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n)
		if n == nil {
			return
		}

		n.AfterState()
	})
}

func Fuzz_NodeInfo_GlobalStates(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n *staker.NodeInfo
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n)
		if n == nil {
			return
		}

		n.GlobalStates()
	})
}

func Fuzz_NodeInfo_MachineStatuses(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n *staker.NodeInfo
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n)
		if n == nil {
			return
		}

		n.MachineStatuses()
	})
}

func Fuzz_RollupWatcher_Initialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *staker.RollupWatcher
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.Initialize(ctx)
	})
}

func Fuzz_RollupWatcher_LatestConfirmedCreationBlock(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *staker.RollupWatcher
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.LatestConfirmedCreationBlock(ctx)
	})
}

func Fuzz_RollupWatcher_LookupChallengedNode(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *staker.RollupWatcher
		var ctx context.Context
		var address common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx, &address)
		if r == nil {
			return
		}

		r.LookupChallengedNode(ctx, address)
	})
}

func Fuzz_RollupWatcher_LookupCreation(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *staker.RollupWatcher
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.LookupCreation(ctx)
	})
}

func Fuzz_RollupWatcher_LookupNode(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *staker.RollupWatcher
		var ctx context.Context
		var number uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx, &number)
		if r == nil {
			return
		}

		r.LookupNode(ctx, number)
	})
}

func Fuzz_RollupWatcher_LookupNodeChildren(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *staker.RollupWatcher
		var ctx context.Context
		var nodeNum uint64
		var nodeHash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx, &nodeNum, &nodeHash)
		if r == nil {
			return
		}

		r.LookupNodeChildren(ctx, nodeNum, nodeHash)
	})
}

func Fuzz_RollupWatcher_StakerInfo(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *staker.RollupWatcher
		var ctx context.Context
		var s3 common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx, &s3)
		if r == nil {
			return
		}

		r.StakerInfo(ctx, s3)
	})
}

func Fuzz_Staker_Act(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *staker.Staker
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.Act(ctx)
	})
}

func Fuzz_Staker_Initialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *staker.Staker
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.Initialize(ctx)
	})
}

func Fuzz_Staker_IsWhitelisted(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *staker.Staker
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.IsWhitelisted(ctx)
	})
}

func Fuzz_Staker_Rollup(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *staker.Staker
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.Rollup()
	})
}

func Fuzz_Staker_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *staker.Staker
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctxIn)
		if s == nil {
			return
		}

		s.Start(ctxIn)
	})
}

func Fuzz_Staker_StopAndWait(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *staker.Staker
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.StopAndWait()
	})
}

func Fuzz_Staker_Strategy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *staker.Staker
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.Strategy()
	})
}

func Fuzz_StatelessBlockValidator_CreateReadyValidationEntry(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.StatelessBlockValidator
		var ctx context.Context
		var pos arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx, &pos)
		if v == nil {
			return
		}

		v.CreateReadyValidationEntry(ctx, pos)
	})
}

func Fuzz_StatelessBlockValidator_GetModuleRootsToValidate(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.StatelessBlockValidator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.GetModuleRootsToValidate()
	})
}

func Fuzz_StatelessBlockValidator_GlobalStatePositionsAtCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.StatelessBlockValidator
		var count arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &count)
		if v == nil {
			return
		}

		v.GlobalStatePositionsAtCount(count)
	})
}

// skipping Fuzz_StatelessBlockValidator_OverrideRecorder because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.BlockRecorder

func Fuzz_StatelessBlockValidator_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.StatelessBlockValidator
		var ctx_in context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx_in)
		if v == nil {
			return
		}

		v.Start(ctx_in)
	})
}

func Fuzz_StatelessBlockValidator_Stop(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.StatelessBlockValidator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v)
		if v == nil {
			return
		}

		v.Stop()
	})
}

func Fuzz_StatelessBlockValidator_ValidateResult(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.StatelessBlockValidator
		var ctx context.Context
		var pos arbutil.MessageIndex
		var useExec bool
		var moduleRoot common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx, &pos, &useExec, &moduleRoot)
		if v == nil {
			return
		}

		v.ValidateResult(ctx, pos, useExec, moduleRoot)
	})
}

func Fuzz_StatelessBlockValidator_ValidationEntryRecord(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var v *staker.StatelessBlockValidator
		var ctx context.Context
		var e *staker.validationEntry
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&v, &ctx, &e)
		if v == nil || e == nil {
			return
		}

		v.ValidationEntryRecord(ctx, e)
	})
}

func Fuzz_ValidatorTxBuilder_Auth(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ValidatorTxBuilder
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx)
		if b == nil {
			return
		}

		b.Auth(ctx)
	})
}

func Fuzz_ValidatorTxBuilder_AuthWithAmount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ValidatorTxBuilder
		var ctx context.Context
		var amount *big.Int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx, &amount)
		if b == nil || amount == nil {
			return
		}

		b.AuthWithAmount(ctx, amount)
	})
}

func Fuzz_ValidatorTxBuilder_BuildingTransactionCount(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ValidatorTxBuilder
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b)
		if b == nil {
			return
		}

		b.BuildingTransactionCount()
	})
}

func Fuzz_ValidatorTxBuilder_ClearTransactions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ValidatorTxBuilder
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b)
		if b == nil {
			return
		}

		b.ClearTransactions()
	})
}

func Fuzz_ValidatorTxBuilder_EstimateGas(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ValidatorTxBuilder
		var ctx context.Context
		var call ethereum.CallMsg
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx, &call)
		if b == nil {
			return
		}

		b.EstimateGas(ctx, call)
	})
}

func Fuzz_ValidatorTxBuilder_SendTransaction(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var b *staker.ValidatorTxBuilder
		var ctx context.Context
		var tx *types.Transaction
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&b, &ctx, &tx)
		if b == nil || tx == nil {
			return
		}

		b.SendTransaction(ctx, tx)
	})
}

func Fuzz_BlockValidatorConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		staker.BlockValidatorConfigAddOptions(prefix, f2)
	})
}

func Fuzz_BlockValidatorDangerousConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		staker.BlockValidatorDangerousConfigAddOptions(prefix, f2)
	})
}

func Fuzz_DangerousConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		staker.DangerousConfigAddOptions(prefix, f2)
	})
}

// skipping Fuzz_FindBatchContainingMessageIndex because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.InboxTrackerInterface

// skipping Fuzz_GetValidatorWalletContract because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.L1ReaderInterface

// skipping Fuzz_GlobalStatePositionsAtCount because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.InboxTrackerInterface

// skipping Fuzz_GlobalStateToMsgCount because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.InboxTrackerInterface

func Fuzz_HashChallengeState(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var segmentStart uint64
		var segmentLength uint64
		var hashes []common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&segmentStart, &segmentLength, &hashes)

		staker.HashChallengeState(segmentStart, segmentLength, hashes)
	})
}

func Fuzz_L1PostingStrategyAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		staker.L1PostingStrategyAddOptions(prefix, f2)
	})
}

func Fuzz_L1ValidatorConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		staker.L1ValidatorConfigAddOptions(prefix, f2)
	})
}

func Fuzz_NewAssertionFromSolidity(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var assertion rollupgen.Assertion
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&assertion)

		staker.NewAssertionFromSolidity(assertion)
	})
}

// skipping Fuzz_NewBlockChallengeBackend because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.TransactionStreamerInterface

// skipping Fuzz_NewBlockValidator because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.InboxTrackerInterface

// skipping Fuzz_NewChallengeManager because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/accounts/abi/bind.ContractBackend

// skipping Fuzz_NewContractValidatorWallet because parameters include func, chan, or unsupported interface: func(github.com/ethereum/go-ethereum/common.Address)

// skipping Fuzz_NewEoaValidatorWallet because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

// skipping Fuzz_NewExecutionChallengeBackend because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/validator.ExecutionRun

// skipping Fuzz_NewExecutionChallengeManager because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/accounts/abi/bind.ContractBackend

// skipping Fuzz_NewL1Validator because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

// skipping Fuzz_NewRollupWatcher because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

// skipping Fuzz_NewStaker because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.L1ReaderInterface

// skipping Fuzz_NewStatelessBlockValidator because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.InboxReaderInterface

// skipping Fuzz_NewValidatorTxBuilder because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/staker.ValidatorWalletInterface

// skipping Fuzz_ReadLastValidatedInfo because parameters include func, chan, or unsupported interface: github.com/ethereum/go-ethereum/ethdb.Database
