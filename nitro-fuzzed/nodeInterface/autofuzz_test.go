package arbcompressfuzz

// Edit if desired. Code generated by "go-fuzz-fill-utils ./nodeInterface/".

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/nodeInterface"
	"github.com/offchainlabs/nitro/precompiles"
)

func Fuzz_NodeInterface_ConstructOutboxProof(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterface
		var c *precompiles.Context
		var evm *vm.EVM
		var size uint64
		var leaf uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c, &evm, &size, &leaf)
		if c == nil || evm == nil {
			return
		}

		n.ConstructOutboxProof(c, evm, size, leaf)
	})
}

func Fuzz_NodeInterface_EstimateRetryableTicket(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterface
		var c *precompiles.Context
		var evm *vm.EVM
		var sender common.Address
		var deposit *big.Int
		var to common.Address
		var l2CallValue *big.Int
		var excessFeeRefundAddress common.Address
		var callValueRefundAddress common.Address
		var d10 []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c, &evm, &sender, &deposit, &to, &l2CallValue, &excessFeeRefundAddress, &callValueRefundAddress, &d10)
		if c == nil || evm == nil || deposit == nil || l2CallValue == nil {
			return
		}

		n.EstimateRetryableTicket(c, evm, sender, deposit, to, l2CallValue, excessFeeRefundAddress, callValueRefundAddress, d10)
	})
}

func Fuzz_NodeInterface_FindBatchContainingBlock(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterface
		var c *precompiles.Context
		var evm *vm.EVM
		var blockNum uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c, &evm, &blockNum)
		if c == nil || evm == nil {
			return
		}

		n.FindBatchContainingBlock(c, evm, blockNum)
	})
}

func Fuzz_NodeInterface_GasEstimateComponents(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterface
		var c *precompiles.Context
		var evm *vm.EVM
		var value *big.Int
		var to common.Address
		var contractCreation bool
		var d7 []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c, &evm, &value, &to, &contractCreation, &d7)
		if c == nil || evm == nil || value == nil {
			return
		}

		n.GasEstimateComponents(c, evm, value, to, contractCreation, d7)
	})
}

func Fuzz_NodeInterface_GasEstimateL1Component(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterface
		var c *precompiles.Context
		var evm *vm.EVM
		var value *big.Int
		var to common.Address
		var contractCreation bool
		var d7 []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c, &evm, &value, &to, &contractCreation, &d7)
		if c == nil || evm == nil || value == nil {
			return
		}

		n.GasEstimateL1Component(c, evm, value, to, contractCreation, d7)
	})
}

func Fuzz_NodeInterface_GetL1Confirmations(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterface
		var c *precompiles.Context
		var evm *vm.EVM
		var blockHash [32]byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c, &evm, &blockHash)
		if c == nil || evm == nil {
			return
		}

		n.GetL1Confirmations(c, evm, blockHash)
	})
}

func Fuzz_NodeInterface_LegacyLookupMessageBatchProof(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterface
		var c *precompiles.Context
		var evm *vm.EVM
		var batchNum *big.Int
		var index uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c, &evm, &batchNum, &index)
		if c == nil || evm == nil || batchNum == nil {
			return
		}

		n.LegacyLookupMessageBatchProof(c, evm, batchNum, index)
	})
}

func Fuzz_NodeInterface_NitroGenesisBlock(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterface
		var c *precompiles.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c)
		if c == nil {
			return
		}

		n.NitroGenesisBlock(c)
	})
}

func Fuzz_NodeInterfaceDebug_GetRetryable(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var n nodeInterface.NodeInterfaceDebug
		var c *precompiles.Context
		var evm *vm.EVM
		var ticket [32]byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&n, &c, &evm, &ticket)
		if c == nil || evm == nil {
			return
		}

		n.GetRetryable(c, evm, ticket)
	})
}
