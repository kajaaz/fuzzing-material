package chaininfofuzz

// Edit if desired. Code generated by "go-fuzz-fill-utils ./ipfshelper/".

import (
	"context"
	"testing"

	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/cmd/ipfshelper"
)

func Fuzz_IpfsHelper_AddFile(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var downloadPath string
		var clientOnly bool
		var peerList []string
		var profiles string
		var c6 context.Context
		var filePath string
		var includeHidden bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &downloadPath, &clientOnly, &peerList, &profiles, &c6, &filePath, &includeHidden)

		h, err := ipfshelper.CreateIpfsHelper(c1, downloadPath, clientOnly, peerList, profiles)
		if err != nil {
			return
		}
		h.AddFile(c6, filePath, includeHidden)
	})
}

func Fuzz_IpfsHelper_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var downloadPath string
		var clientOnly bool
		var peerList []string
		var profiles string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &downloadPath, &clientOnly, &peerList, &profiles)

		h, err := ipfshelper.CreateIpfsHelper(ctx, downloadPath, clientOnly, peerList, profiles)
		if err != nil {
			return
		}
		h.Close()
	})
}

func Fuzz_IpfsHelper_DownloadFile(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var downloadPath string
		var clientOnly bool
		var peerList []string
		var profiles string
		var c6 context.Context
		var cidString string
		var destinationDir string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &downloadPath, &clientOnly, &peerList, &profiles, &c6, &cidString, &destinationDir)

		h, err := ipfshelper.CreateIpfsHelper(c1, downloadPath, clientOnly, peerList, profiles)
		if err != nil {
			return
		}
		h.DownloadFile(c6, cidString, destinationDir)
	})
}

func Fuzz_IpfsHelper_GetAPI(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var downloadPath string
		var clientOnly bool
		var peerList []string
		var profiles string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &downloadPath, &clientOnly, &peerList, &profiles)

		h, err := ipfshelper.CreateIpfsHelper(ctx, downloadPath, clientOnly, peerList, profiles)
		if err != nil {
			return
		}
		h.GetAPI()
	})
}

func Fuzz_IpfsHelper_GetPeerHostAddresses(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var downloadPath string
		var clientOnly bool
		var peerList []string
		var profiles string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &downloadPath, &clientOnly, &peerList, &profiles)

		h, err := ipfshelper.CreateIpfsHelper(ctx, downloadPath, clientOnly, peerList, profiles)
		if err != nil {
			return
		}
		h.GetPeerHostAddresses()
	})
}

func Fuzz_CanBeIpfsPath(f *testing.F) {
	f.Fuzz(func(t *testing.T, pathString string) {
		ipfshelper.CanBeIpfsPath(pathString)
	})
}

func Fuzz_CreateIpfsHelper(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var downloadPath string
		var clientOnly bool
		var peerList []string
		var profiles string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &downloadPath, &clientOnly, &peerList, &profiles)

		ipfshelper.CreateIpfsHelper(ctx, downloadPath, clientOnly, peerList, profiles)
	})
}
