package util

// Edit if desired. Code generated by "go-fuzz-fill-utils ./redisutil/".

import (
	"context"
	"testing"

	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/arbutil"
	"github.com/offchainlabs/nitro/util/redisutil"
)

func Fuzz_RedisCoordinator_CurrentChosenSequencer(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var redisUrl string
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&redisUrl, &ctx)

		c, err := redisutil.NewRedisCoordinator(redisUrl)
		if err != nil {
			return
		}
		c.CurrentChosenSequencer(ctx)
	})
}

func Fuzz_RedisCoordinator_RecommendSequencerWantingLockout(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var redisUrl string
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&redisUrl, &ctx)

		c, err := redisutil.NewRedisCoordinator(redisUrl)
		if err != nil {
			return
		}
		c.RecommendSequencerWantingLockout(ctx)
	})
}

func Fuzz_CreateTestRedis(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var t2 *testing.T
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &t2)
		if t2 == nil {
			return
		}

		redisutil.CreateTestRedis(ctx, t2)
	})
}

func Fuzz_MessageKeyFor(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var pos arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&pos)

		redisutil.MessageKeyFor(pos)
	})
}

func Fuzz_MessageSigKeyFor(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var pos arbutil.MessageIndex
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&pos)

		redisutil.MessageSigKeyFor(pos)
	})
}

func Fuzz_NewRedisCoordinator(f *testing.F) {
	f.Fuzz(func(t *testing.T, redisUrl string) {
		redisutil.NewRedisCoordinator(redisUrl)
	})
}

func Fuzz_RedisClientFromURL(f *testing.F) {
	f.Fuzz(func(t *testing.T, url string) {
		redisutil.RedisClientFromURL(url)
	})
}

func Fuzz_WantsLockoutKeyFor(f *testing.F) {
	f.Fuzz(func(t *testing.T, url string) {
		redisutil.WantsLockoutKeyFor(url)
	})
}
