package util

// Edit if desired. Code generated by "go-fuzz-fill-utils ./headerreader/".

import (
	"context"
	"testing"

	"github.com/ethereum/go-ethereum/core/types"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/util/headerreader"
	"github.com/spf13/pflag"
)

func Fuzz_HeaderReader_Client(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.Client()
	})
}

func Fuzz_HeaderReader_IsParentChainArbitrum(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.IsParentChainArbitrum()
	})
}

func Fuzz_HeaderReader_LastHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.LastHeader(ctx)
	})
}

func Fuzz_HeaderReader_LastHeaderWithError(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.LastHeaderWithError()
	})
}

func Fuzz_HeaderReader_LastPendingCallBlockNr(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.LastPendingCallBlockNr()
	})
}

func Fuzz_HeaderReader_LatestFinalizedBlockHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.LatestFinalizedBlockHeader(ctx)
	})
}

func Fuzz_HeaderReader_LatestFinalizedBlockNr(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.LatestFinalizedBlockNr(ctx)
	})
}

func Fuzz_HeaderReader_LatestSafeBlockHeader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.LatestSafeBlockHeader(ctx)
	})
}

func Fuzz_HeaderReader_LatestSafeBlockNr(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.LatestSafeBlockNr(ctx)
	})
}

func Fuzz_HeaderReader_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		var ctxIn context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctxIn)
		if s == nil {
			return
		}

		s.Start(ctxIn)
	})
}

func Fuzz_HeaderReader_StopAndWait(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.StopAndWait()
	})
}

func Fuzz_HeaderReader_Subscribe(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		var requireBlockNrUpdates bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &requireBlockNrUpdates)
		if s == nil {
			return
		}

		s.Subscribe(requireBlockNrUpdates)
	})
}

func Fuzz_HeaderReader_UpdatingPendingCallBlockNr(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.UpdatingPendingCallBlockNr()
	})
}

func Fuzz_HeaderReader_UseFinalityData(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.UseFinalityData()
	})
}

func Fuzz_HeaderReader_WaitForTxApproval(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *headerreader.HeaderReader
		var ctxIn context.Context
		var tx *types.Transaction
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctxIn, &tx)
		if s == nil || tx == nil {
			return
		}

		s.WaitForTxApproval(ctxIn, tx)
	})
}

func Fuzz_AddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		headerreader.AddOptions(prefix, f2)
	})
}

func Fuzz_HeadersEqual(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ha *types.Header
		var hb *types.Header
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ha, &hb)
		if ha == nil || hb == nil {
			return
		}

		headerreader.HeadersEqual(ha, hb)
	})
}

// skipping Fuzz_New because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface
