package util

// Edit if desired. Code generated by "go-fuzz-fill-utils ./merkletree/".

import (
	"io"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/arbos/merkleAccumulator"
	"github.com/offchainlabs/nitro/util/merkletree"
)

func Fuzz_MerkleProof_IsCorrect(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var proof *merkletree.MerkleProof
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&proof)
		if proof == nil {
			return
		}

		proof.IsCorrect()
	})
}

func Fuzz_LevelAndLeaf_ToBigInt(f *testing.F) {
	f.Fuzz(func(t *testing.T, level uint64, leaf uint64) {
		place := merkletree.NewLevelAndLeaf(level, leaf)
		place.ToBigInt()
	})
}

func Fuzz_NewLevelAndLeaf(f *testing.F) {
	f.Fuzz(func(t *testing.T, level uint64, leaf uint64) {
		merkletree.NewLevelAndLeaf(level, leaf)
	})
}

func Fuzz_NewMerkleEmpty(f *testing.F) {
	f.Fuzz(func(t *testing.T, capacity uint64) {
		merkletree.NewMerkleEmpty(capacity)
	})
}

// skipping Fuzz_NewMerkleInternal because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/util/merkletree.MerkleTree

func Fuzz_NewMerkleLeaf(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&hash)

		merkletree.NewMerkleLeaf(hash)
	})
}

func Fuzz_NewMerkleTreeFromAccumulator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var acc *merkleAccumulator.MerkleAccumulator
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&acc)
		if acc == nil {
			return
		}

		merkletree.NewMerkleTreeFromAccumulator(acc)
	})
}

func Fuzz_NewMerkleTreeFromEvents(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var events []merkleAccumulator.MerkleTreeNodeEvent
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&events)

		merkletree.NewMerkleTreeFromEvents(events)
	})
}

func Fuzz_NewMerkleTreeFromReader(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rd io.Reader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rd)

		merkletree.NewMerkleTreeFromReader(rd)
	})
}

func Fuzz_NewNonPersistentMerkleAccumulatorFromEvents(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var events []merkleAccumulator.MerkleTreeNodeEvent
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&events)

		merkletree.NewNonPersistentMerkleAccumulatorFromEvents(events)
	})
}

func Fuzz_NewSummaryMerkleTree(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var hash common.Hash
		var capacity uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&hash, &capacity)

		merkletree.NewSummaryMerkleTree(hash, capacity)
	})
}
