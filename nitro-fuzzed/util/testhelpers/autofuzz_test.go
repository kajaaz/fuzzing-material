package util

// Edit if desired. Code generated by "go-fuzz-fill-utils ./testhelpers/".

import (
	"testing"

	"github.com/ethereum/go-ethereum/log"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/util/testhelpers"
)

func Fuzz_LogHandler_Log(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *testing.T
		var level log.Lvl
		var record *log.Record
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &level, &record)
		if t1 == nil || record == nil {
			return
		}

		h := testhelpers.InitTestLog(t1, level)
		h.Log(record)
	})
}

func Fuzz_LogHandler_WasLogged(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *testing.T
		var level log.Lvl
		var pattern string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &level, &pattern)
		if t1 == nil {
			return
		}

		h := testhelpers.InitTestLog(t1, level)
		h.WasLogged(pattern)
	})
}

func Fuzz_PseudoRandomDataSource_GetAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var _x1 *testing.T
		var seed int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&_x1, &seed)
		if _x1 == nil {
			return
		}

		r := testhelpers.NewPseudoRandomDataSource(_x1, seed)
		r.GetAddress()
	})
}

func Fuzz_PseudoRandomDataSource_GetData(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var _x1 *testing.T
		var seed int64
		var size int
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&_x1, &seed, &size)
		if _x1 == nil {
			return
		}

		r := testhelpers.NewPseudoRandomDataSource(_x1, seed)
		r.GetData(size)
	})
}

func Fuzz_PseudoRandomDataSource_GetHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var _x1 *testing.T
		var seed int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&_x1, &seed)
		if _x1 == nil {
			return
		}

		r := testhelpers.NewPseudoRandomDataSource(_x1, seed)
		r.GetHash()
	})
}

func Fuzz_PseudoRandomDataSource_GetUint64(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var _x1 *testing.T
		var seed int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&_x1, &seed)
		if _x1 == nil {
			return
		}

		r := testhelpers.NewPseudoRandomDataSource(_x1, seed)
		r.GetUint64()
	})
}

// skipping Fuzz_FailImpl because parameters include func, chan, or unsupported interface: []interface{}

func Fuzz_InitTestLog(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 *testing.T
		var level log.Lvl
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &level)
		if t1 == nil {
			return
		}

		testhelpers.InitTestLog(t1, level)
	})
}

func Fuzz_NewPseudoRandomDataSource(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var _x1 *testing.T
		var seed int64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&_x1, &seed)
		if _x1 == nil {
			return
		}

		testhelpers.NewPseudoRandomDataSource(_x1, seed)
	})
}

func Fuzz_RandomizeSlice(f *testing.F) {
	f.Fuzz(func(t *testing.T, slice []byte) {
		testhelpers.RandomizeSlice(slice)
	})
}

// skipping Fuzz_RequireImpl because parameters include func, chan, or unsupported interface: error
