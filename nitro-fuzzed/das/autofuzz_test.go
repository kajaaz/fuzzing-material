package arbcompressfuzz

// Edit if desired. Code generated by "go-fuzz-fill-utils ./das/".

import (
	"context"
	"testing"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/infosecual/go-fuzz-fill-utils/fuzzer"
	"github.com/offchainlabs/nitro/arbstate"
	"github.com/offchainlabs/nitro/das"
	"github.com/offchainlabs/nitro/solgen/go/bridgegen"
	"github.com/offchainlabs/nitro/util/headerreader"
	"github.com/spf13/pflag"
)

func Fuzz_Aggregator_Store(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config das.DataAvailabilityConfig
		var services []das.ServiceDetails
		var c4 context.Context
		var message []byte
		var timeout uint64
		var sig []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &services, &c4, &message, &timeout, &sig)

		a, err := das.NewAggregator(c1, config, services)
		if err != nil {
			return
		}
		a.Store(c4, message, timeout, sig)
	})
}

func Fuzz_Aggregator_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config das.DataAvailabilityConfig
		var services []das.ServiceDetails
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config, &services)

		a, err := das.NewAggregator(ctx, config, services)
		if err != nil {
			return
		}
		a.String()
	})
}

func Fuzz_BigCacheStorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var bcs *das.BigCacheStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&bcs, &ctx)
		if bcs == nil {
			return
		}

		bcs.Close(ctx)
	})
}

func Fuzz_BigCacheStorageService_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var bcs *das.BigCacheStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&bcs, &ctx)
		if bcs == nil {
			return
		}

		bcs.ExpirationPolicy(ctx)
	})
}

func Fuzz_BigCacheStorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var bcs *das.BigCacheStorageService
		var ctx context.Context
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&bcs, &ctx, &key)
		if bcs == nil {
			return
		}

		bcs.GetByHash(ctx, key)
	})
}

func Fuzz_BigCacheStorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var bcs *das.BigCacheStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&bcs, &ctx)
		if bcs == nil {
			return
		}

		bcs.HealthCheck(ctx)
	})
}

func Fuzz_BigCacheStorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var bcs *das.BigCacheStorageService
		var ctx context.Context
		var value []byte
		var timeout uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&bcs, &ctx, &value, &timeout)
		if bcs == nil {
			return
		}

		bcs.Put(ctx, value, timeout)
	})
}

func Fuzz_BigCacheStorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var bcs *das.BigCacheStorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&bcs)
		if bcs == nil {
			return
		}

		bcs.String()
	})
}

func Fuzz_BigCacheStorageService_Sync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var bcs *das.BigCacheStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&bcs, &ctx)
		if bcs == nil {
			return
		}

		bcs.Sync(ctx)
	})
}

func Fuzz_ChainFetchReader_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *das.ChainFetchReader
		var ctx context.Context
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c, &ctx, &hash)
		if c == nil {
			return
		}

		c.GetByHash(ctx, hash)
	})
}

func Fuzz_ChainFetchReader_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *das.ChainFetchReader
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.String()
	})
}

func Fuzz_DASRPCClient_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 string
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &ctx)

		c, err := das.NewDASRPCClient(t1)
		if err != nil {
			return
		}
		c.ExpirationPolicy(ctx)
	})
}

func Fuzz_DASRPCClient_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 string
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &ctx)

		c, err := das.NewDASRPCClient(t1)
		if err != nil {
			return
		}
		c.HealthCheck(ctx)
	})
}

func Fuzz_DASRPCClient_Store(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var t1 string
		var ctx context.Context
		var message []byte
		var timeout uint64
		var reqSig []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&t1, &ctx, &message, &timeout, &reqSig)

		c, err := das.NewDASRPCClient(t1)
		if err != nil {
			return
		}
		c.Store(ctx, message, timeout, reqSig)
	})
}

func Fuzz_DASRPCClient_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, t1 string) {
		c, err := das.NewDASRPCClient(t1)
		if err != nil {
			return
		}
		c.String()
	})
}

func Fuzz_DASRPCServer_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var serv *das.DASRPCServer
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&serv, &ctx)
		if serv == nil {
			return
		}

		serv.ExpirationPolicy(ctx)
	})
}

func Fuzz_DASRPCServer_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var serv *das.DASRPCServer
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&serv, &ctx)
		if serv == nil {
			return
		}

		serv.HealthCheck(ctx)
	})
}

func Fuzz_DASRPCServer_Store(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var serv *das.DASRPCServer
		var ctx context.Context
		var message hexutil.Bytes
		var timeout hexutil.Uint64
		var sig hexutil.Bytes
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&serv, &ctx, &message, &timeout, &sig)
		if serv == nil {
			return
		}

		serv.Store(ctx, message, timeout, sig)
	})
}

func Fuzz_DBStorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dbs *das.DBStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dbs, &ctx)
		if dbs == nil {
			return
		}

		dbs.Close(ctx)
	})
}

func Fuzz_DBStorageService_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dbs *das.DBStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dbs, &ctx)
		if dbs == nil {
			return
		}

		dbs.ExpirationPolicy(ctx)
	})
}

func Fuzz_DBStorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dbs *das.DBStorageService
		var ctx context.Context
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dbs, &ctx, &key)
		if dbs == nil {
			return
		}

		dbs.GetByHash(ctx, key)
	})
}

func Fuzz_DBStorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dbs *das.DBStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dbs, &ctx)
		if dbs == nil {
			return
		}

		dbs.HealthCheck(ctx)
	})
}

func Fuzz_DBStorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dbs *das.DBStorageService
		var ctx context.Context
		var d3 []byte
		var timeout uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dbs, &ctx, &d3, &timeout)
		if dbs == nil {
			return
		}

		dbs.Put(ctx, d3, timeout)
	})
}

func Fuzz_DBStorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dbs *das.DBStorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dbs)
		if dbs == nil {
			return
		}

		dbs.String()
	})
}

func Fuzz_DBStorageService_Sync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var dbs *das.DBStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&dbs, &ctx)
		if dbs == nil {
			return
		}

		dbs.Sync(ctx)
	})
}

func Fuzz_FallbackStorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var f1 *das.FallbackStorageService
		var ctx context.Context
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&f1, &ctx, &key)
		if f1 == nil {
			return
		}

		f1.GetByHash(ctx, key)
	})
}

func Fuzz_FallbackStorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var f1 *das.FallbackStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&f1, &ctx)
		if f1 == nil {
			return
		}

		f1.HealthCheck(ctx)
	})
}

func Fuzz_FallbackStorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var f1 *das.FallbackStorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&f1)
		if f1 == nil {
			return
		}

		f1.String()
	})
}

func Fuzz_IpfsStorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config das.IpfsStorageServiceConfig
		var c3 context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3)

		s, err := das.NewIpfsStorageService(c1, config)
		if err != nil {
			return
		}
		s.Close(c3)
	})
}

func Fuzz_IpfsStorageService_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config das.IpfsStorageServiceConfig
		var c3 context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3)

		s, err := das.NewIpfsStorageService(c1, config)
		if err != nil {
			return
		}
		s.ExpirationPolicy(c3)
	})
}

func Fuzz_IpfsStorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config das.IpfsStorageServiceConfig
		var c3 context.Context
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3, &hash)

		s, err := das.NewIpfsStorageService(c1, config)
		if err != nil {
			return
		}
		s.GetByHash(c3, hash)
	})
}

func Fuzz_IpfsStorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config das.IpfsStorageServiceConfig
		var c3 context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3)

		s, err := das.NewIpfsStorageService(c1, config)
		if err != nil {
			return
		}
		s.HealthCheck(c3)
	})
}

func Fuzz_IpfsStorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config das.IpfsStorageServiceConfig
		var c3 context.Context
		var d4 []byte
		var timeout uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3, &d4, &timeout)

		s, err := das.NewIpfsStorageService(c1, config)
		if err != nil {
			return
		}
		s.Put(c3, d4, timeout)
	})
}

func Fuzz_IpfsStorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config das.IpfsStorageServiceConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config)

		s, err := das.NewIpfsStorageService(ctx, config)
		if err != nil {
			return
		}
		s.String()
	})
}

func Fuzz_IpfsStorageService_Sync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config das.IpfsStorageServiceConfig
		var c3 context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3)

		s, err := das.NewIpfsStorageService(c1, config)
		if err != nil {
			return
		}
		s.Sync(c3)
	})
}

func Fuzz_IterableStorageService_DefaultBegin(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *das.IterableStorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i)
		if i == nil {
			return
		}

		i.DefaultBegin()
	})
}

func Fuzz_IterableStorageService_End(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *das.IterableStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &ctx)
		if i == nil {
			return
		}

		i.End(ctx)
	})
}

func Fuzz_IterableStorageService_GetExpirationTime(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *das.IterableStorageService
		var ctx context.Context
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &ctx, &hash)
		if i == nil {
			return
		}

		i.GetExpirationTime(ctx, hash)
	})
}

func Fuzz_IterableStorageService_Next(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *das.IterableStorageService
		var ctx context.Context
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &ctx, &hash)
		if i == nil {
			return
		}

		i.Next(ctx, hash)
	})
}

func Fuzz_IterableStorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var i *das.IterableStorageService
		var ctx context.Context
		var d3 []byte
		var expiration uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&i, &ctx, &d3, &expiration)
		if i == nil {
			return
		}

		i.Put(ctx, d3, expiration)
	})
}

func Fuzz_KeyConfig_BLSPrivKey(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *das.KeyConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		c.BLSPrivKey()
	})
}

// skipping Fuzz_LifecycleManager_Register because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.Closer

func Fuzz_LifecycleManager_StopAndWaitUntil(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *das.LifecycleManager
		var t2 time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &t2)
		if m == nil {
			return
		}

		m.StopAndWaitUntil(t2)
	})
}

func Fuzz_LocalFileStorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.LocalFileStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.Close(ctx)
	})
}

func Fuzz_LocalFileStorageService_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.LocalFileStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.ExpirationPolicy(ctx)
	})
}

func Fuzz_LocalFileStorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.LocalFileStorageService
		var ctx context.Context
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx, &key)
		if s == nil {
			return
		}

		s.GetByHash(ctx, key)
	})
}

func Fuzz_LocalFileStorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.LocalFileStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.HealthCheck(ctx)
	})
}

func Fuzz_LocalFileStorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.LocalFileStorageService
		var ctx context.Context
		var d3 []byte
		var timeout uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx, &d3, &timeout)
		if s == nil {
			return
		}

		s.Put(ctx, d3, timeout)
	})
}

func Fuzz_LocalFileStorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.LocalFileStorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.String()
	})
}

func Fuzz_LocalFileStorageService_Sync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.LocalFileStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.Sync(ctx)
	})
}

func Fuzz_MemoryBackedStorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *das.MemoryBackedStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx)
		if m == nil {
			return
		}

		m.Close(ctx)
	})
}

func Fuzz_MemoryBackedStorageService_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *das.MemoryBackedStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx)
		if m == nil {
			return
		}

		m.ExpirationPolicy(ctx)
	})
}

func Fuzz_MemoryBackedStorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *das.MemoryBackedStorageService
		var ctx context.Context
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx, &key)
		if m == nil {
			return
		}

		m.GetByHash(ctx, key)
	})
}

func Fuzz_MemoryBackedStorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *das.MemoryBackedStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx)
		if m == nil {
			return
		}

		m.HealthCheck(ctx)
	})
}

func Fuzz_MemoryBackedStorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *das.MemoryBackedStorageService
		var ctx context.Context
		var d3 []byte
		var expirationTime uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx, &d3, &expirationTime)
		if m == nil {
			return
		}

		m.Put(ctx, d3, expirationTime)
	})
}

func Fuzz_MemoryBackedStorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *das.MemoryBackedStorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m)
		if m == nil {
			return
		}

		m.String()
	})
}

func Fuzz_MemoryBackedStorageService_Sync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var m *das.MemoryBackedStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&m, &ctx)
		if m == nil {
			return
		}

		m.Sync(ctx)
	})
}

func Fuzz_ReaderPanicWrapper_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *das.ReaderPanicWrapper
		var ctx context.Context
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ctx, &hash)
		if w == nil {
			return
		}

		w.GetByHash(ctx, hash)
	})
}

func Fuzz_ReaderPanicWrapper_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *das.ReaderPanicWrapper
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.String()
	})
}

func Fuzz_ReaderTimeoutWrapper_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *das.ReaderTimeoutWrapper
		var ctx context.Context
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ctx, &hash)
		if w == nil {
			return
		}

		w.GetByHash(ctx, hash)
	})
}

func Fuzz_ReaderTimeoutWrapper_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *das.ReaderTimeoutWrapper
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.String()
	})
}

func Fuzz_RedisStorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rs *das.RedisStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rs, &ctx)
		if rs == nil {
			return
		}

		rs.Close(ctx)
	})
}

func Fuzz_RedisStorageService_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rs *das.RedisStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rs, &ctx)
		if rs == nil {
			return
		}

		rs.ExpirationPolicy(ctx)
	})
}

func Fuzz_RedisStorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rs *das.RedisStorageService
		var ctx context.Context
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rs, &ctx, &key)
		if rs == nil {
			return
		}

		rs.GetByHash(ctx, key)
	})
}

func Fuzz_RedisStorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rs *das.RedisStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rs, &ctx)
		if rs == nil {
			return
		}

		rs.HealthCheck(ctx)
	})
}

func Fuzz_RedisStorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rs *das.RedisStorageService
		var ctx context.Context
		var value []byte
		var timeout uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rs, &ctx, &value, &timeout)
		if rs == nil {
			return
		}

		rs.Put(ctx, value, timeout)
	})
}

func Fuzz_RedisStorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rs *das.RedisStorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rs)
		if rs == nil {
			return
		}

		rs.String()
	})
}

func Fuzz_RedisStorageService_Sync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rs *das.RedisStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rs, &ctx)
		if rs == nil {
			return
		}

		rs.Sync(ctx)
	})
}

func Fuzz_RedundantStorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *das.RedundantStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.Close(ctx)
	})
}

func Fuzz_RedundantStorageService_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *das.RedundantStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.ExpirationPolicy(ctx)
	})
}

func Fuzz_RedundantStorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *das.RedundantStorageService
		var ctx context.Context
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx, &key)
		if r == nil {
			return
		}

		r.GetByHash(ctx, key)
	})
}

func Fuzz_RedundantStorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *das.RedundantStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.HealthCheck(ctx)
	})
}

func Fuzz_RedundantStorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *das.RedundantStorageService
		var ctx context.Context
		var d3 []byte
		var expirationTime uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx, &d3, &expirationTime)
		if r == nil {
			return
		}

		r.Put(ctx, d3, expirationTime)
	})
}

func Fuzz_RedundantStorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *das.RedundantStorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r)
		if r == nil {
			return
		}

		r.String()
	})
}

func Fuzz_RedundantStorageService_Sync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *das.RedundantStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.Sync(ctx)
	})
}

func Fuzz_RegularlySyncStorage_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var r *das.RegularlySyncStorage
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&r, &ctx)
		if r == nil {
			return
		}

		r.Start(ctx)
	})
}

func Fuzz_RestfulDasClient_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var protocol string
		var host string
		var port int
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&protocol, &host, &port, &ctx)

		c := das.NewRestfulDasClient(protocol, host, port)
		c.ExpirationPolicy(ctx)
	})
}

func Fuzz_RestfulDasClient_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var protocol string
		var host string
		var port int
		var ctx context.Context
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&protocol, &host, &port, &ctx, &hash)

		c := das.NewRestfulDasClient(protocol, host, port)
		c.GetByHash(ctx, hash)
	})
}

func Fuzz_RestfulDasClient_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var protocol string
		var host string
		var port int
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&protocol, &host, &port, &ctx)

		c := das.NewRestfulDasClient(protocol, host, port)
		c.HealthCheck(ctx)
	})
}

// skipping Fuzz_RestfulDasServer_ExpirationPolicyHandler because parameters include func, chan, or unsupported interface: net/http.ResponseWriter

// skipping Fuzz_RestfulDasServer_GetByHashHandler because parameters include func, chan, or unsupported interface: net/http.ResponseWriter

func Fuzz_RestfulDasServer_GetServerExitedChan(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rds *das.RestfulDasServer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rds)
		if rds == nil {
			return
		}

		rds.GetServerExitedChan()
	})
}

// skipping Fuzz_RestfulDasServer_HealthHandler because parameters include func, chan, or unsupported interface: net/http.ResponseWriter

// skipping Fuzz_RestfulDasServer_ServeHTTP because parameters include func, chan, or unsupported interface: net/http.ResponseWriter

func Fuzz_RestfulDasServer_Shutdown(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rds *das.RestfulDasServer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rds)
		if rds == nil {
			return
		}

		rds.Shutdown()
	})
}

func Fuzz_RestfulDasServer_WaitForShutdown(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var rds *das.RestfulDasServer
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&rds)
		if rds == nil {
			return
		}

		rds.WaitForShutdown()
	})
}

func Fuzz_S3StorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s3s *das.S3StorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s3s, &ctx)
		if s3s == nil {
			return
		}

		s3s.Close(ctx)
	})
}

func Fuzz_S3StorageService_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s3s *das.S3StorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s3s, &ctx)
		if s3s == nil {
			return
		}

		s3s.ExpirationPolicy(ctx)
	})
}

func Fuzz_S3StorageService_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s3s *das.S3StorageService
		var ctx context.Context
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s3s, &ctx, &key)
		if s3s == nil {
			return
		}

		s3s.GetByHash(ctx, key)
	})
}

func Fuzz_S3StorageService_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s3s *das.S3StorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s3s, &ctx)
		if s3s == nil {
			return
		}

		s3s.HealthCheck(ctx)
	})
}

func Fuzz_S3StorageService_Put(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s3s *das.S3StorageService
		var ctx context.Context
		var value []byte
		var timeout uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s3s, &ctx, &value, &timeout)
		if s3s == nil {
			return
		}

		s3s.Put(ctx, value, timeout)
	})
}

func Fuzz_S3StorageService_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s3s *das.S3StorageService
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s3s)
		if s3s == nil {
			return
		}

		s3s.String()
	})
}

func Fuzz_S3StorageService_Sync(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s3s *das.S3StorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s3s, &ctx)
		if s3s == nil {
			return
		}

		s3s.Sync(ctx)
	})
}

func Fuzz_ServiceDetails_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.ServiceDetails
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.String()
	})
}

func Fuzz_SignAfterStoreDASWriter_Store(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var d *das.SignAfterStoreDASWriter
		var ctx context.Context
		var message []byte
		var timeout uint64
		var sig []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&d, &ctx, &message, &timeout, &sig)
		if d == nil {
			return
		}

		d.Store(ctx, message, timeout, sig)
	})
}

func Fuzz_SignAfterStoreDASWriter_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var d *das.SignAfterStoreDASWriter
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&d)
		if d == nil {
			return
		}

		d.String()
	})
}

func Fuzz_SimpleDASReaderAggregator_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config *das.RestfulClientAggregatorConfig
		var c3 context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3)
		if config == nil {
			return
		}

		a, err := das.NewRestfulClientAggregator(c1, config)
		if err != nil {
			return
		}
		a.Close(c3)
	})
}

func Fuzz_SimpleDASReaderAggregator_ExpirationPolicy(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config *das.RestfulClientAggregatorConfig
		var c3 context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3)
		if config == nil {
			return
		}

		a, err := das.NewRestfulClientAggregator(c1, config)
		if err != nil {
			return
		}
		a.ExpirationPolicy(c3)
	})
}

func Fuzz_SimpleDASReaderAggregator_GetByHash(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config *das.RestfulClientAggregatorConfig
		var c3 context.Context
		var hash common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3, &hash)
		if config == nil {
			return
		}

		a, err := das.NewRestfulClientAggregator(c1, config)
		if err != nil {
			return
		}
		a.GetByHash(c3, hash)
	})
}

func Fuzz_SimpleDASReaderAggregator_HealthCheck(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config *das.RestfulClientAggregatorConfig
		var c3 context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3)
		if config == nil {
			return
		}

		a, err := das.NewRestfulClientAggregator(c1, config)
		if err != nil {
			return
		}
		a.HealthCheck(c3)
	})
}

func Fuzz_SimpleDASReaderAggregator_Start(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c1 context.Context
		var config *das.RestfulClientAggregatorConfig
		var c3 context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c1, &config, &c3)
		if config == nil {
			return
		}

		a, err := das.NewRestfulClientAggregator(c1, config)
		if err != nil {
			return
		}
		a.Start(c3)
	})
}

func Fuzz_SimpleDASReaderAggregator_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config *das.RestfulClientAggregatorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config)
		if config == nil {
			return
		}

		a, err := das.NewRestfulClientAggregator(ctx, config)
		if err != nil {
			return
		}
		a.String()
	})
}

func Fuzz_StoreSigningDAS_SignerAddress(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.StoreSigningDAS
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.SignerAddress()
	})
}

func Fuzz_StoreSigningDAS_Store(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.StoreSigningDAS
		var ctx context.Context
		var message []byte
		var timeout uint64
		var sig []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx, &message, &timeout, &sig)
		if s == nil {
			return
		}

		s.Store(ctx, message, timeout, sig)
	})
}

func Fuzz_StoreSigningDAS_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.StoreSigningDAS
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s)
		if s == nil {
			return
		}

		s.String()
	})
}

func Fuzz_SyncingFallbackStorageService_Close(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var s *das.SyncingFallbackStorageService
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&s, &ctx)
		if s == nil {
			return
		}

		s.Close(ctx)
	})
}

func Fuzz_WriterPanicWrapper_Store(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *das.WriterPanicWrapper
		var ctx context.Context
		var message []byte
		var timeout uint64
		var sig []byte
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w, &ctx, &message, &timeout, &sig)
		if w == nil {
			return
		}

		w.Store(ctx, message, timeout, sig)
	})
}

func Fuzz_WriterPanicWrapper_String(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var w *das.WriterPanicWrapper
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&w)
		if w == nil {
			return
		}

		w.String()
	})
}

func Fuzz_AggregatorConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.AggregatorConfigAddOptions(prefix, f2)
	})
}

func Fuzz_BigCacheConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.BigCacheConfigAddOptions(prefix, f2)
	})
}

// skipping Fuzz_ConvertStorageServiceToIterationCompatibleStorageService because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.StorageService

// skipping Fuzz_CreateBatchPosterDAS because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/util/signature.DataSignerFunc

func Fuzz_CreateDAComponentsForDaserver(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config *das.DataAvailabilityConfig
		var l1Reader *headerreader.HeaderReader
		var seqInboxAddress *common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config, &l1Reader, &seqInboxAddress)
		if config == nil || l1Reader == nil || seqInboxAddress == nil {
			return
		}

		das.CreateDAComponentsForDaserver(ctx, config, l1Reader, seqInboxAddress)
	})
}

func Fuzz_CreateDAReaderForNode(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config *das.DataAvailabilityConfig
		var l1Reader *headerreader.HeaderReader
		var seqInboxAddress *common.Address
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config, &l1Reader, &seqInboxAddress)
		if config == nil || l1Reader == nil || seqInboxAddress == nil {
			return
		}

		das.CreateDAReaderForNode(ctx, config, l1Reader, seqInboxAddress)
	})
}

// skipping Fuzz_CreatePersistentStorageService because parameters include func, chan, or unsupported interface: *[]github.com/offchainlabs/nitro/das.StorageService

func Fuzz_DasRecoverSigner(f *testing.F) {
	f.Fuzz(func(t *testing.T, d1 []byte, timeout uint64, sig []byte) {
		das.DasRecoverSigner(d1, timeout, sig)
	})
}

func Fuzz_DataAvailabilityConfigAddDaserverOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.DataAvailabilityConfigAddDaserverOptions(prefix, f2)
	})
}

func Fuzz_DataAvailabilityConfigAddNodeOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.DataAvailabilityConfigAddNodeOptions(prefix, f2)
	})
}

func Fuzz_DecodeBase64BLSPrivateKey(f *testing.F) {
	f.Fuzz(func(t *testing.T, privKeyEncodedBytes []byte) {
		das.DecodeBase64BLSPrivateKey(privKeyEncodedBytes)
	})
}

func Fuzz_DecodeBase64BLSPublicKey(f *testing.F) {
	f.Fuzz(func(t *testing.T, pubKeyEncodedBytes []byte) {
		das.DecodeBase64BLSPublicKey(pubKeyEncodedBytes)
	})
}

func Fuzz_DecodeStorageServiceKey(f *testing.F) {
	f.Fuzz(func(t *testing.T, input string) {
		das.DecodeStorageServiceKey(input)
	})
}

func Fuzz_EncodeStorageServiceKey(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var key common.Hash
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&key)

		das.EncodeStorageServiceKey(key)
	})
}

// skipping Fuzz_FindDASDataFromLog because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

func Fuzz_GenerateAndStoreECDSAKeys(f *testing.F) {
	f.Fuzz(func(t *testing.T, dir string) {
		das.GenerateAndStoreECDSAKeys(dir)
	})
}

func Fuzz_GenerateAndStoreKeys(f *testing.F) {
	f.Fuzz(func(t *testing.T, keyDir string) {
		das.GenerateAndStoreKeys(keyDir)
	})
}

func Fuzz_GetL1Client(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var maxConnectionAttempts int
		var l1URL string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &maxConnectionAttempts, &l1URL)

		das.GetL1Client(ctx, maxConnectionAttempts, l1URL)
	})
}

func Fuzz_IpfsStorageServiceConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.IpfsStorageServiceConfigAddOptions(prefix, f2)
	})
}

func Fuzz_KeyConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.KeyConfigAddOptions(prefix, f2)
	})
}

func Fuzz_KeysetHashFromServices(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var services []das.ServiceDetails
		var assumedHonest uint64
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&services, &assumedHonest)

		das.KeysetHashFromServices(services, assumedHonest)
	})
}

func Fuzz_LocalDBStorageConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.LocalDBStorageConfigAddOptions(prefix, f2)
	})
}

func Fuzz_LocalFileStorageConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.LocalFileStorageConfigAddOptions(prefix, f2)
	})
}

func Fuzz_NewAggregator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config das.DataAvailabilityConfig
		var services []das.ServiceDetails
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config, &services)

		das.NewAggregator(ctx, config, services)
	})
}

// skipping Fuzz_NewAggregatorWithL1Info because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

func Fuzz_NewAggregatorWithSeqInboxCaller(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config das.DataAvailabilityConfig
		var services []das.ServiceDetails
		var seqInboxCaller *bridgegen.SequencerInboxCaller
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &services, &seqInboxCaller)
		if seqInboxCaller == nil {
			return
		}

		das.NewAggregatorWithSeqInboxCaller(config, services, seqInboxCaller)
	})
}

// skipping Fuzz_NewBigCacheStorageService because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.StorageService

// skipping Fuzz_NewChainFetchReader because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbstate.DataAvailabilityReader

// skipping Fuzz_NewChainFetchReaderWithSeqInbox because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbstate.DataAvailabilityReader

func Fuzz_NewDASRPCClient(f *testing.F) {
	f.Fuzz(func(t *testing.T, t1 string) {
		das.NewDASRPCClient(t1)
	})
}

func Fuzz_NewDBStorageService(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var dirPath string
		var discardAfterTimeout bool
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &dirPath, &discardAfterTimeout)

		das.NewDBStorageService(ctx, dirPath, discardAfterTimeout)
	})
}

// skipping Fuzz_NewFallbackStorageService because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.StorageService

func Fuzz_NewIpfsStorageService(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config das.IpfsStorageServiceConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config)

		das.NewIpfsStorageService(ctx, config)
	})
}

// skipping Fuzz_NewIterableStorageService because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.IterationCompatibleStorageService

func Fuzz_NewLocalFileStorageService(f *testing.F) {
	f.Fuzz(func(t *testing.T, dataDir string) {
		das.NewLocalFileStorageService(dataDir)
	})
}

func Fuzz_NewMemoryBackedStorageService(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx)

		das.NewMemoryBackedStorageService(ctx)
	})
}

func Fuzz_NewRPCAggregator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config das.DataAvailabilityConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config)

		das.NewRPCAggregator(ctx, config)
	})
}

// skipping Fuzz_NewRPCAggregatorWithL1Info because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbutil.L1Interface

func Fuzz_NewRPCAggregatorWithSeqInboxCaller(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config das.DataAvailabilityConfig
		var seqInboxCaller *bridgegen.SequencerInboxCaller
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config, &seqInboxCaller)
		if seqInboxCaller == nil {
			return
		}

		das.NewRPCAggregatorWithSeqInboxCaller(config, seqInboxCaller)
	})
}

// skipping Fuzz_NewReadLimitedDataAvailabilityService because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbstate.DataAvailabilityReader

// skipping Fuzz_NewReadLimitedStorageService because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbstate.DataAvailabilityReader

// skipping Fuzz_NewReaderPanicWrapper because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.DataAvailabilityServiceReader

// skipping Fuzz_NewReaderTimeoutWrapper because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.DataAvailabilityServiceReader

// skipping Fuzz_NewRedisStorageService because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.StorageService

// skipping Fuzz_NewRedundantStorageService because parameters include func, chan, or unsupported interface: []github.com/offchainlabs/nitro/das.StorageService

// skipping Fuzz_NewRegularlySyncStorage because parameters include func, chan, or unsupported interface: []github.com/offchainlabs/nitro/das.StorageService

func Fuzz_NewRestfulClientAggregator(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var config *das.RestfulClientAggregatorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &config)
		if config == nil {
			return
		}

		das.NewRestfulClientAggregator(ctx, config)
	})
}

func Fuzz_NewRestfulDasClient(f *testing.F) {
	f.Fuzz(func(t *testing.T, protocol string, host string, port int) {
		das.NewRestfulDasClient(protocol, host, port)
	})
}

func Fuzz_NewRestfulDasClientFromURL(f *testing.F) {
	f.Fuzz(func(t *testing.T, url string) {
		das.NewRestfulDasClientFromURL(url)
	})
}

// skipping Fuzz_NewRestfulDasServer because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/arbstate.DataAvailabilityReader

// skipping Fuzz_NewRestfulDasServerOnListener because parameters include func, chan, or unsupported interface: net.Listener

func Fuzz_NewS3StorageService(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config das.S3StorageServiceConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)

		das.NewS3StorageService(config)
	})
}

// skipping Fuzz_NewServiceDetails because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.DataAvailabilityServiceWriter

// skipping Fuzz_NewSignAfterStoreDASWriter because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.StorageService

// skipping Fuzz_NewSignAfterStoreDASWriterWithSeqInboxCaller because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.StorageService

// skipping Fuzz_NewStoreSigningDAS because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.DataAvailabilityServiceWriter

// skipping Fuzz_NewSyncingFallbackStorageService because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.StorageService

// skipping Fuzz_NewWriterPanicWrapper because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.DataAvailabilityServiceWriter

func Fuzz_OptionalAddressFromString(f *testing.F) {
	f.Fuzz(func(t *testing.T, s string) {
		das.OptionalAddressFromString(s)
	})
}

func Fuzz_ParseServices(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var config das.AggregatorConfig
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&config)

		das.ParseServices(config)
	})
}

func Fuzz_ReadKeysFromFile(f *testing.F) {
	f.Fuzz(func(t *testing.T, keyDir string) {
		das.ReadKeysFromFile(keyDir)
	})
}

func Fuzz_ReadPrivKeyFromFile(f *testing.F) {
	f.Fuzz(func(t *testing.T, privKeyPath string) {
		das.ReadPrivKeyFromFile(privKeyPath)
	})
}

func Fuzz_ReadPubKeyFromFile(f *testing.F) {
	f.Fuzz(func(t *testing.T, pubKeyPath string) {
		das.ReadPubKeyFromFile(pubKeyPath)
	})
}

func Fuzz_RedisConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.RedisConfigAddOptions(prefix, f2)
	})
}

func Fuzz_RegularSyncStorageConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.RegularSyncStorageConfigAddOptions(prefix, f2)
	})
}

func Fuzz_RestfulClientAggregatorConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.RestfulClientAggregatorConfigAddOptions(prefix, f2)
	})
}

func Fuzz_RestfulServerURLsFromList(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var listUrl string
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &listUrl)

		das.RestfulServerURLsFromList(ctx, listUrl)
	})
}

func Fuzz_S3ConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.S3ConfigAddOptions(prefix, f2)
	})
}

func Fuzz_Serialize(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var c *arbstate.DataAvailabilityCertificate
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&c)
		if c == nil {
			return
		}

		das.Serialize(c)
	})
}

func Fuzz_SimpleExploreExploitStrategyConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.SimpleExploreExploitStrategyConfigAddOptions(prefix, f2)
	})
}

// skipping Fuzz_StartDASRPCServer because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.DataAvailabilityServiceReader

// skipping Fuzz_StartDASRPCServerOnListener because parameters include func, chan, or unsupported interface: net.Listener

func Fuzz_StartRestfulServerListFetchDaemon(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var ctx context.Context
		var listUrl string
		var updatePeriod time.Duration
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&ctx, &listUrl, &updatePeriod)

		das.StartRestfulServerListFetchDaemon(ctx, listUrl, updatePeriod)
	})
}

func Fuzz_SyncToStorageConfigAddOptions(f *testing.F) {
	f.Fuzz(func(t *testing.T, data []byte) {
		var prefix string
		var f2 *pflag.FlagSet
		fz := fuzzer.NewFuzzer(data)
		fz.Fill(&prefix, &f2)
		if f2 == nil {
			return
		}

		das.SyncToStorageConfigAddOptions(prefix, f2)
	})
}

// skipping Fuzz_WrapStorageWithCache because parameters include func, chan, or unsupported interface: github.com/offchainlabs/nitro/das.StorageService
